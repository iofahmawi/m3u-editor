<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M3U Editor</title>

     <!-- === New Additions for PWA === -->
    <meta name="theme-color" content="#fdfcfb">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="icon-1024.png">
    <link rel="apple-touch-icon" href="icon-1024.png">
    <!-- ============================= -->

    <!-- Plyr.io CSS (New) -->
    <link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    
    <style>
        /* Warm & Minimalist Theme with Final Polishing */
        :root {
            --primary-color: #e67e22; /* Carrot Orange */
            --primary-hover: #de6800;
            --secondary-color: #34495e; /* Wet Asphalt Blue */
            --secondary-hover: #2c3e50;
            --delete-color: #c0392b; /* Pomegranate Red for delete actions */
            --delete-hover: #a93226;
            --button-delete-color: #546e7a; /* Neutral dark grey for delete buttons */
            --button-delete-hover: #455a64;
            --background-color: #fdfcfb; /* Very Light Beige */
            --container-bg-color: #ffffff;
            --text-color: #5D4037; /* Warm Dark Brown */
            --text-light-color: #ffffff;
            --border-color: #e0e0e0;
            --row-alt-color: #f7f7f7;
            --selected-row-color: #fdebd0;
            --border-radius: 12px; /* Added for new player compatibility */
        }
        
        /* --- START: Screenshot Matched Night Mode --- */
        body.dark-mode {
            --primary-color: #f08c2a;
            --primary-hover: #d35400;
            --secondary-color: #3a3a3c;
            --secondary-hover: #4a4a4c;
            --button-delete-color: #3a3a3c;
            --button-delete-hover: #4a4a4c;
            --background-color: #282828; 
            --container-bg-color: #282828; 
            --text-color: #ffffff; 
            --text-light-color: #ffffff;
            --border-color: #444444; 
            --row-alt-color: #1c1c1e; 
            --selected-row-color: rgba(240, 140, 42, 0.2);
        }
        /* --- END: Screenshot Matched Night Mode --- */

        html {
            height: 100%;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            direction: ltr; /* MODIFIED */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s;
        }

        button, a, [onclick], .upload-area {
            -webkit-tap-highlight-color: transparent;
        }

        .container {
            max-width: 1100px; width: 100%; margin: 20px auto;
            background: var(--container-bg-color);
            padding: 30px; border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            box-sizing: border-box;
            border: 1px solid var(--border-color);
            transition: background-color 0.3s, border-color 0.3s;
            position: relative;
        }
        body.dark-mode .container {
             border: 1px solid #1c1c1e;
        }
        
        #theme-toggle {
            position: absolute;
            top: 1.5px;
            right: 1.5px; /* MODIFIED */
            left: auto; /* MODIFIED */
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            display: flex;
            color: #e0e0e0;
            transition: opacity 0.2s;
        }
        
        body.dark-mode #theme-toggle {
            color: #EAEAEA;
        }

        #theme-toggle:hover {
           opacity: 0.8;
        }

        #theme-toggle svg {
            width: 24px;
            height: 24px;
        }

        .moon-icon { display: none; }
        .sun-icon { display: block; }
        
        body.dark-mode .moon-icon { display: block; }
        body.dark-mode .sun-icon { display: none; }
        
        h1 { color: var(--primary-color); text-align: center; margin-bottom: 20px; }
        .page-title {
            color: inherit;
            text-decoration: none;
        }

        .upload-area {
            text-align: center; padding: 20px;
            border: 2px dashed var(--border-color);
            border-radius: 12px; margin-bottom: 20px; cursor: pointer;
            transition: border-color 0.3s, background-color 0.3s; box-sizing: border-box;
        }
        .upload-area:hover, .upload-area.dragging {
            border-color: var(--primary-color);
            background-color: #fffaf5;
        }
        body.dark-mode .upload-area:hover, body.dark-mode .upload-area.dragging {
            background-color: rgba(240, 140, 42, 0.1);
        }
        .upload-label {
            background-color: var(--primary-color);
            color: var(--text-light-color);
            padding: 0 25px;
            height: 40px;
            line-height: 40px;
            border-radius: 10px; cursor: pointer;
            font-weight: bold; display: inline-block;
            transition: background-color 0.3s; border: none; margin-top: 10px;
            font-size: 15.5px;
        }
        .upload-label:hover { background-color: var(--primary-hover); }

        .action-btn {
    /* الخصائص الأصلية المحافظ عليها */
    background-color: var(--secondary-color);
    color: white;
    border-radius: 10px;
    cursor: pointer;
    font-weight: bold;
    border: none;
    transition: background-color 0.3s, opacity 0.3s;
    margin: 10px 5px;
    flex-shrink: 0;
    white-space: nowrap;
    font-size: 0.86em;

    /* --- التحديثات لتوحيد الارتفاع --- */
    height: 38px;                  /* 1. تحديد ارتفاع ثابت (يمكنك تعديل القيمة) */
    display: inline-flex;          /* 2. استخدام flexbox للتحكم في المحاذاة */
    align-items: center;           /* 3. توسيط المحتوى (النص) عمودياً */
    justify-content: center;       /* (اختياري) توسيط المحتوى أفقياً لمظهر أفضل */
    padding: 0 20px;               /* 4. إزالة الحشوة العمودية والمحافظة على الأفقية */
}
        body.dark-mode .action-btn {
            color: var(--text-light-color);
        }
        .action-btn:hover:not(:disabled) { background-color: var(--secondary-hover); }
        .action-btn.delete-btn { background-color: var(--button-delete-color); }
        .action-btn.delete-btn:hover { background-color: var(--button-delete-hover); }
        .action-btn.export-btn { background-color: var(--primary-color); color: var(--text-light-color); }
        .action-btn.export-btn:hover { background-color: var(--primary-hover); }

        /* --- START: MODIFICATION FOR BULK ACTIONS BUTTON --- */
        .action-btn:disabled:not(#bulkActionsButton) {
            background-color: var(--secondary-color);
            cursor: not-allowed; opacity: 0.6;
        }
        .action-btn:disabled:hover:not(#bulkActionsButton) { background-color: var(--secondary-color); }

        #bulkActionsButton:disabled {
            cursor: not-allowed;
        }
        /* --- END: MODIFICATION FOR BULK ACTIONS BUTTON --- */


        #manageGroupsButton, #openSortModalButton, #removeDuplicatesButton, #addChannelButton, #openMergeModalButton, #openExportModalButton, #bulkActionsButton { display: none; }
        #mainControls { text-align: center; margin-bottom: 20px; }
        .button-row { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 10px; margin-bottom: 10px; }
        
        @media (max-width: 768px) {
            #toolsMergeRow > .action-btn, 
            #toolsMergeRow > .advanced-tools-dropdown {
                flex: 1 1 40%;
                margin: 5px 0;
            }
        }

        #searchInput, #groupFilter {
            padding: 10px; border: 1px solid var(--border-color);
            border-radius: 8px; box-sizing: border-box; font-size: 16px;
            outline: none; transition: border-color 0.3s, box-shadow 0.3s;
            background-color: var(--container-bg-color); width: 100%; margin-bottom: 15px;
            color: var(--text-color);
        }
        
        input[type="text"]:focus,
        input[type="url"]:focus,
        input[type="number"]:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: inset 0 0 0 2px rgba(240, 140, 42, 0.25);
        }

        #groupFilter { text-align: center; text-align-last: center; }

        #results { 
            text-align: center; 
        }
        table { 
            width: 100%; 
            margin: 20px auto; 
            table-layout: fixed; 
            border-spacing: 0;
            border-collapse: separate;
            border-radius: 8px;
        }
        /* Common properties for all cells */
        th, td {
            border: 1px solid var(--border-color);
            text-align: center;
            box-sizing: border-box;
            overflow: hidden;
            vertical-align: middle;
            word-wrap: break-word;
        }

        /* Control header row height */
        th {
    height: 34px;              /* 1. تحديد ارتفاع ثابت لصف العنوان */
    padding: 0 4px;            /* 2. إلغاء الحشوة العمودية والإبقاء على الأفقية */

    /* الخصائص التالية موجودة في قاعدة th, td العامة ونبقي عليها */
    vertical-align: middle;
}

        /* Control data row height */
        /* التحكم بارتفاع صفوف البيانات (Rows) */
td {
    height: 46px;              /* 1. تحديد ارتفاع ثابت لصفوف البيانات */
    padding: 0 4px;            /* 2. إلغاء الحشوة العمودية والإبقاء على الأفقية */

    /* الخصائص التالية موجودة في قاعدة th, td العامة ونبقي عليها */
    vertical-align: middle;
}
        th { background-color: var(--primary-color); color: white; }
        body.dark-mode th {
            color: #1a1a1a;
            font-weight: bold;
        }
        
        body.dark-mode td {
            color: #ffffff;
        }
        
        th:first-child { border-top-left-radius: 8px; } /* MODIFIED */
        th:last-child { border-top-right-radius: 8px; } /* MODIFIED */
        tbody tr:last-child td:first-child { border-bottom-left-radius: 8px; } /* MODIFIED */
        tbody tr:last-child td:last-child { border-bottom-right-radius: 8px; } /* MODIFIED */

        tr:nth-child(even) { background-color: var(--row-alt-color); }
        body.dark-mode tr:nth-child(even) {
            background-color: var(--container-bg-color);
        }
        
        tbody tr { 
            cursor: grab; 
            -webkit-tap-highlight-color: transparent;
            outline: none;
        } 
        tbody tr:not([draggable="true"]) {
            cursor: default;
        }
        tbody tr.drag-over-indicator {
            background-color: var(--selected-row-color) !important;
        }
        tr.selected { background-color: var(--selected-row-color) !important; }

        body.is-dragging tr.selected {
            background-color: transparent !important;
        }
        body.is-dragging tr:nth-child(even).selected {
            background-color: var(--row-alt-color) !important;
        }

        table th:nth-child(1), table td:nth-child(1) { width: 15%; min-width: 80px; }
        table th:nth-child(2), table td:nth-child(2) { width: 60%; min-width: 150px;}
        table th:nth-child(3), table td:nth-child(3) { width: 25%; min-width: 80px; }
        table th:nth-child(4), table td:nth-child(4) { display: none; }
        
        .channel-index-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0px;
        }
        
        td.channel-name {
    position: relative;
    padding-left: 45px; /* <-- هذا السطر يضيف مساحة على اليسار لوضع الصورة فيها */
}

        td.channel-name img,
td.channel-name .placeholder {
    position: absolute; 
    left: 8px; /* <-- هذا السطر يضع الصورة على بعد 8 بكسل من الحافة اليسرى */
    top: 50%; 
    transform: translateY(-50%); 
    width: 30px;
    height: 30px;
    object-fit: contain;
    cursor: pointer; 
}

        td.channel-name .name-text {
            text-align: center;
            white-space: normal !important;
            word-break: break-word;
            overflow: hidden;
            direction: ltr;
        }
        
        td.channel-group { direction: ltr; }

        .action-button-icon { background: none; border: none; cursor: pointer; font-size: 1.2em; margin: 0 1px; padding: 5px 3px; display: inline-block; text-align: center; color: var(--secondary-color); font-weight: bold; transition: color 0.3s; }
        .action-button-icon:hover { color: var(--secondary-hover); }
        .delete-btn-icon { color: var(--button-delete-color); }
        .delete-btn-icon:hover { color: var(--button-delete-hover); }
        
        .play-btn-icon {
            color: #5cb85c;
            font-size: 1.1em;
            vertical-align: middle;
            display: none;
        }
        .play-btn-icon:hover {
            color: #4cae4c;
        }
        body.play-mode-enabled .play-btn-icon {
            display: inline-block;
        }

        .modal-content { background-color: var(--container-bg-color); }
        
        /* =================================================================== */
/* === START: FINAL ENGLISH-ONLY TOAST STYLES                      === */
/* =================================================================== */

/* --- 1. The main container for all notifications (Positioned on the RIGHT) --- */
#toastContainer {
    position: fixed;
    top: 20px;
    right: 20px;
    left: auto;
    z-index: 2000;
    display: flex;
    flex-direction: column;
    gap: 10px;
    direction: ltr; 
}

/* --- 2. The animation wrapper (Moves from and to the RIGHT) --- */
.toast-wrapper {
    opacity: 0;
    transform: translateX(-120%); /* Starts off-screen to the right */
    transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
}
.toast-wrapper.show {
    opacity: 1;
    transform: translateX(0);
}

/* --- 3. The notification box itself --- */
.toast {
    display: flex;
    align-items: center;
    gap: 10px;
    min-width: 300px;
    background-color: #fff;
    color: #333;
    padding: 12px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    box-sizing: border-box;
    /* --- Border is ALWAYS on the RIGHT --- */
    border-right: 5px solid #ccc;
    border-left: none;
}

/* --- 4. The Close Button (X) - Visually on the LEFT --- */
.toast-close {
    order: 1; /* This places the close button FIRST (visually on the left) */
    background: none;
    border: none;
    color: #aaa;
    font-size: 20px;
    cursor: pointer;
    padding: 0 5px;
    flex-shrink: 0;
}
.toast-close:hover {
    color: #333;
}

/* --- 5. Content (Text) - Fills the middle space --- */
.toast-content {
    order: 2; /* Text comes after the close button */
    flex-grow: 1; /* Takes all available space */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    text-align: left;
}

/* --- 6. Action button ("Undo") - Is last on the right --- */
.toast-action {
    order: 3; /* Action button is last */
    color: var(--primary-color);
    cursor: pointer;
    font-weight: bold;
    margin: 0 5px;
}

/* --- 7. Dark Mode Styles --- */
body.dark-mode .toast {
    background-color: #333;
    color: #fff;
}
body.dark-mode .toast-close:hover {
    color: #fff;
}

/* --- 8. Border Colors (Applied to the right border) --- */
.toast.success { border-right-color: var(--primary-color); }
.toast.error   { border-right-color: var(--delete-color); }
.toast.info    { border-right-color: var(--secondary-color); }
.toast.play    { border-right-color: var(--primary-color); } 
body.dark-mode .toast.info {
    border-right-color: #85c1e9;
}

/* =================================================================== */
/* === END: FINAL ENGLISH-ONLY TOAST STYLES                        === */
/* =================================================================== */
        
        #paginationControls { display: flex; justify-content: center; align-items: center; margin-top: 20px; gap: 10px; } 
        #paginationControls button { background-color: #f0f0f0; border: 1px solid var(--border-color); padding: 7.5px 16px; border-radius: 4px; cursor: pointer; }
        #paginationControls button:disabled { background-color: #e9ecef; cursor: not-allowed; }
        body.dark-mode #paginationControls button {
            background-color: #444;
            color: var(--text-color);
        }
        body.dark-mode #paginationControls button:disabled {
            background-color: #333;
            color: #888;
        }
        #pageInfo { font-weight: bold; } #confirmModal .modal-content { max-width: 400px; text-align: center; } #confirmMessage { margin: 20px 0; font-size: 1.1em; } 
        
        .modal { 
            display: none; 
            position: fixed; 
            z-index: 2000;
            left: 0; top: 0; 
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.7); 
            align-items: center;
            justify-content: center; 
            padding-top: 0;
        } 

        .modal-content { padding: 20px; border: 1px solid var(--border-color); width: auto; max-width: 500px; border-radius: 15px; position: relative; box-sizing: border-box; overflow-y: auto; max-height: 90vh; margin: auto; } .modal-content textarea { 
    width: 95%; 
    min-height: 150px; 
    padding: 8px; 
    margin: 10px auto; 
    display: block; 
    border: 1px solid var(--border-color); 
    border-radius: 8px;
    box-sizing: border-box; 
} 

        #multiUrlTextarea,
        #mergeUrlTextarea,
        #format-remove-words-input {
            resize: none;
        }
        
        #multiUrlTextarea { direction: ltr; text-align: left; } 
        
        .merge-option-container {
            padding-left: 0;
            padding-right: 0;
        }
        
        #mergeUrlTextarea {
            width: calc(100% - 2px);
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        /* --- START: MODIFICATION FOR CLOSE BUTTON --- */
        .close {
            position: absolute;
            top: 10px;
            right: 15px; /* MODIFIED */
            left: auto; /* MODIFIED */
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
        }
        .close:hover, .close:focus { color: #000; text-decoration: none; cursor: pointer; } 
        /* --- END: MODIFICATION FOR CLOSE BUTTON --- */
        
        body.dark-mode .close { color: #ccc; } 
        body.dark-mode .close:hover { color: #fff; }
/* General rule for inputs in modals */
.modal-content input[type="text"], .modal-content input[type="url"], .modal-content input[type="number"], .modal-content select { 
    width: 95%; 
    padding: 8.5px 9px; 
    margin: 10px 0; 
    display: inline-block; 
    border: 1px solid var(--border-color); 
    border-radius: 8px;
    box-sizing: border-box; 
    transition: border-color 0.3s, box-shadow 0.3s;
    background-color: #FFFFFF;
}

/* Exception and customization for specific dropdowns */
#formatDataModal #format-scope-selector,
#sortModal #sort-scope-selector,
#manageGroupsModal #groupSelector,
#findReplaceModal #replace-scope-selector {
    padding: 9px;
    font-size: 0.9em;
} 
        body.dark-mode .modal-content input[type="text"], 
        body.dark-mode .modal-content input[type="url"], 
        body.dark-mode .modal-content input[type="number"], 
        body.dark-mode .modal-content select,
        body.dark-mode .modal-content textarea {
            background-color: #3a3a3a;
            color: var(--text-color);
            border-color: #555;
        }
        .modal-content input[type="radio"], .modal-content input[type="checkbox"] { 
            margin: 10px 5px;
            accent-color: var(--primary-color);
        } 
        .modal-content input[type="radio"]:disabled + label {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .modal-content button {
    /* الخصائص الأصلية المحافظ عليها */
    background-color: var(--primary-color);
    color: var(--text-light-color);
    border: none;
    border-radius: 10px;
    font-weight: bold;
    cursor: pointer;
    margin-right: 3px; /* أو margin-left حسب اتجاه صفحتك */
    box-sizing: border-box;
    min-width: 80px;

    /* --- التحديثات لتوحيد الارتفاع --- */
    height: 38px;                  /* 1. تحديد ارتفاع ثابت وموحد (نفس قيمة الأزرار الرئيسية) */
    display: inline-flex;          /* 2. استخدام flexbox للمحاذاة */
    align-items: center;           /* 3. توسيط المحتوى (النص) عمودياً */
    justify-content: center;       /* (اختياري) توسيط المحتوى أفقياً لمظهر أفضل */
    padding: 0 20px;               /* 4. إلغاء الحشوة العمودية والمحافظة على الأفقية */
}
        .modal-content button.cancel { background-color: var(--button-delete-color); color: white; } 
        .modal-content button:hover { opacity: 0.8; } 
        .modal-row { display: flex; align-items: center; margin-bottom: 10px; } 
        .modal-row label { margin-right: 5px; margin-left: 0; cursor: pointer; flex-shrink: 0; }
        .modal-buttons {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 25px;
            flex-wrap: wrap;
            gap: 10px;
            width: 100%;
        }

        .modal-form-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 25px;
        }
        #addModal .modal-content h2,
        #editModal .modal-content h2 {
            width: 100%;
            margin-bottom: 30px;
        }
        .modal-form-row label {
            flex-basis: 110px; /* Adjusted for English labels */
            flex-shrink: 0;
            text-align: left; /* MODIFIED */
        }
        #addModal .modal-form-row input,
        #editModal .modal-form-row input {
            width: 100%;
            margin: 0;
        }
        #addLogoPreview, #logoPreview {
            margin-left: auto; /* MODIFIED */
            margin-right: 0;
            padding-right: 5px; /* MODIFIED */
            padding-left: 0;
        }
        
        .popup { 
            position: fixed; 
            z-index: 3000;
            inset: 0; 
            background-color: rgba(0,0,0,0.8); 
            backdrop-filter: blur(5px); 
            display: none; 
            align-items: flex-start; 
            justify-content: center; 
            padding-top: 27vh;
        }
        .popup.active { display: flex; }
        /* This line allows the popup to move freely */
        .popup-content { 
            overflow: visible; 
        }

        /* This new line fixes the toolbar issue */
        .plyr--video {
            overflow: hidden;
            border-radius: var(--border-radius); 
        }
        
        .popup-content { 
            position: relative; 
            background-color: transparent; 
            width: 95%; 
            max-width: 800px; 
            touch-action: none;
        }
        .popup-content.dragging {
            cursor: grabbing;
            user-select: none;
        }

        #player-container .plyr { 
            border-radius: var(--border-radius); 
        }
        
        #duplicate-results-list {
            margin-top: 15px; 
        }

        .duplicate-group { border: 1px solid var(--border-color); border-radius: 6px; margin-bottom: 10px; padding: 10px; }
        .duplicate-group h4 { margin: 0 0 10px 0; font-size: 1.1em; color: var(--primary-color); }
        .duplicate-channel-item { display: flex; align-items: center; }
        .duplicate-channel-item label { display: flex; align-items: center; padding: 5px; border-radius: 4px; cursor: pointer; width: 100%; }
        .duplicate-channel-item label:hover { background-color: var(--row-alt-color); }
        .duplicate-channel-item input { margin-left: 8px; margin-right: 0; flex-shrink: 0; }
        .duplicate-channel-item .dup-logo { width: 25px; height: 25px; object-fit: contain; margin-right: 8px; margin-left: 0; flex-shrink: 0; }
        .duplicate-channel-item .dup-logo-placeholder { width: 25px; text-align: center; margin-right: 8px; margin-left: 0; flex-shrink: 0; }
        .duplicate-channel-item .dup-info-icon { margin-left: auto; margin-right: 0; cursor: pointer; color: var(--secondary-color); font-size: 1.2em; padding: 5px; }

        #bulk-actions-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px 0;
        }
        #bulk-actions-list .modal-row {
            flex-wrap: wrap;
        }
        
        #bulk-move-input-container {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-in-out, margin-top 0.4s ease-in-out;
            width: 100%;
            margin-top: 0;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            padding-left: 25px; /* MODIFIED */
            padding-right: 0;
        }
        #bulk-move-input-container.visible {
            max-height: 100px;
            margin-top: 10px;
        }
        #bulk-move-input-container label {
            margin: 0 8px 0 0; /* MODIFIED */
            white-space: nowrap;
        }
        #bulk-move-target-index {
            flex-grow: 1;
            margin: 0;
            padding: 8px;
            font-size: 1em;
            text-align: left; /* MODIFIED */
            width: auto;
        }

        .dropdown-container {
            position: relative;
            display: inline-block;
            width: 100%;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
        }
        #channelCheckerModal .dropdown-btn {
            width: 100%;
            background-color: var(--secondary-color) !important;
            color: white;
            padding: 7.5px 10px;
            font-size: 1em;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            text-align: center;
            transition: background-color: 0.3s;
        }
        #channelCheckerModal .dropdown-btn:hover {
            background-color: var(--secondary-hover) !important;
        }
        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #f9f9f9;
            min-width: 100%;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
            border-radius: 8px;
            overflow: hidden;
            bottom: 100%;
            margin-bottom: 5px;
        }
        .dropdown-content a {
            color: black;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            text-align: left; /* MODIFIED */
            border-bottom: 1px solid var(--border-color);
        }
        .dropdown-content a:last-child {
            border-bottom: none;
        }
        .dropdown-content a:hover {
            background-color: #f1f1f1;
        }
        .dropdown-content a.delete-option {
            color: var(--delete-color);
            font-weight: bold;
        }
        .dropdown-content a.delete-option:hover {
            background-color: #f5c2bf;
        }
        .show {
            display: block;
        }
        
        /* START: CSS Refactoring */
        #sortByNameInputContainer, #sortByGroupInputContainer, #moveBlockInputContainer,
        #renameGroupInputContainer, #mergeGroupInputContainer {
            max-height: 0;
            overflow: hidden;
            margin: 0 0 0 25px; /* MODIFIED */
        }
        #sortByNameInputContainer, #sortByGroupInputContainer, #moveBlockInputContainer {
            transition: max-height 0.4s ease-in-out, margin 0.4s ease-in-out;
        }
        #renameGroupInputContainer, #mergeGroupInputContainer {
            transition: all 0.4s ease-in-out;
            padding: 0;
        }

        #sortByNameInputContainer.visible, #sortByGroupInputContainer.visible,
        #mergeGroupInputContainer.visible {
            max-height: 100px;
            margin-bottom: 10px;
        }
        #renameGroupInputContainer.visible {
            max-height: 150px;
            margin-bottom: 10px;
        }
        /* END: CSS Refactoring */

        #moveBlockInputContainer.visible {
            max-height: 200px;
        }
        
        .move-block-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .move-block-row label {
            flex-shrink: 0;
        }
        .move-block-row input {
            width: 100px;
        }
        
        .modal-content.compact-layout .modal-row { margin-bottom: 2px; }
        .modal-content.compact-layout .move-block-row { margin-bottom: 4px; }
        .modal-content.compact-layout .modal-buttons { margin-top: 10px; }
        .modal-content.compact-layout #moveBlockInputContainer { padding-top: 5px; padding-bottom: 5px; }

        #loadingIndicator { font-weight: bold; color: var(--primary-color); text-align: center; margin: 20px; } #logoPreview img, #addPreviewImage { max-width: 50px; max-height: 50px; display: none; } 
        #mergeModal .modal-content-body {
            padding: 0;
            text-align: left; /* MODIFIED */
            margin-top: 20px;
        } 
        #mergeOptionSelector { width: 100%; padding: 10px; font-size: 1em; margin-bottom: 20px; } 
        .merge-option-container {
            padding: 10px;
            text-align: center;
        } 
        .merge-option-container p {
    margin-top: 0;      /* <-- هذا السطر الجديد يزيل المسافة العلوية */
    margin-bottom: 20px;
    color: #666;
}
        body.dark-mode .merge-option-container p { color: #ccc; }
        .merge-option-container button { background-color: var(--primary-color); color: white; padding: 7.5px 25px; font-size: 1em; border: none; border-radius: 10px; cursor: pointer; }
        .merge-option-container button:hover { background-color: var(--primary-hover); } 
        .status-dot { height: 10px; width: 10px; border-radius: 50%; display: none; margin-right: 5px; margin-left: 0; } /* MODIFIED */
        .status-dot.unchecked { background-color: #bbb; } .status-dot.checking { background-color: #f0ad4e; animation: blinker 1s linear infinite; } .status-dot.checked-ok { background-color: #5cb85c; } .status-dot.checked-fail { background-color: var(--delete-color); } @keyframes blinker { 50% { opacity: 0.5; } } #checker-progress-bar-container { width: 100%; background-color: #e0e0e0; border-radius: 5px; margin: 15px 0; } body.dark-mode #checker-progress-bar-container { background-color: #444; } #checker-progress-bar { width: 0%; height: 20px; background-color: var(--primary-color); border-radius: 5px; text-align: center; line-height: 20px; color: white; transition: width 0.3s; } .find-replace-options div { margin-bottom: 5px; }
        
        #modal-options-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 14px;
            margin-top: 20px;
        }
        #modal-options-list button {
            width: 100%;
            padding: 8px;
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 0.86em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #modal-options-list button:hover {
            background-color: var(--secondary-hover);
        }
        
#advancedOptionsModal .modal-content {
    padding-bottom: 17px; /* You can adjust this value as needed */
}
       
/* START: FINAL FIX FOR TABS */
.library-tabs {
    overflow: hidden;
    border: 1px solid var(--border-color);
    background-color: var(--row-alt-color);
    display: flex;
    border-radius: 8px;
    margin-top: 15px;
    box-sizing: border-box;
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
}

.library-tabs button {
    background-color: inherit;
    flex: 1; 
    min-width: 0; 
    border: none;
    outline: none;
    cursor: pointer;
    padding: 8px 6px; 
    font-size: 0.85em; 
    color: var(--text-color);
    font-weight: bold;
    -webkit-tap-highlight-color: transparent;
    white-space: nowrap; 
    transition: none !important;
}
.library-tabs button:first-child { border-radius: 4px 0 0 4px; } /* MODIFIED */
.library-tabs button:last-child { border-radius: 0 4px 4px 0; } /* MODIFIED */
.library-tabs button:hover { background-color: #e0e0e0; }
.library-tabs button.active { background-color: #e8e8e8; color: var(--text-color); cursor: default; }
body.dark-mode .library-tabs button:hover { background-color: #2c2c2e; }
body.dark-mode .library-tabs button.active { background-color: #3a3a3c; color: var(--text-color); }
.library-tab-pane { display: none; padding: 15px 0 0 0; border-top: none; }

/* -- New Container Rule -- */
.format-container {
    border: 1px solid var(--border-color);
    border-radius: 8px;
    margin-top: 15px;
    overflow: hidden; /* Crucial for containing the rounded corners */
}

/* -- Modified .format-tabs -- */
.format-tabs {
    border: none; /* The container handles the border now */
    background-color: var(--row-alt-color);
    display: flex;
    box-sizing: border-box;
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
    width: 100%;
}

.format-tabs button {
    background-color: inherit;
    flex: 1; 
    min-width: 0; 
    border: none;
    outline: none;
    cursor: pointer;
    padding: 5px 6px; 
    font-size: 0.85em; 
    color: var(--text-color);
    font-weight: bold;
    -webkit-tap-highlight-color: transparent;
    white-space: nowrap; 
    transition: none !important;
}

.format-tabs button:hover { background-color: #e0e0e0; }
.format-tabs button.active { background-color: #e8e8e8; color: var(--text-color); cursor: default; }
body.dark-mode .format-tabs button:hover { background-color: #2c2c2e; }
body.dark-mode .format-tabs button.active { background-color: #3a3a3c; color: var(--text-color); }


/* -- Modified .format-tab-pane -- */
.format-tab-pane {
    max-height: 0;
    overflow: hidden;
    border: none; /* The container handles the border now */
    padding: 0 20px;
    box-sizing: border-box;
    transition: max-height 0.4s ease-in-out, padding-top 0.4s ease-in-out, padding-bottom 0.4s ease-in-out;
}

.format-tab-pane.active {
    max-height: 500px; /* Increased max-height */
    padding: 20px;
}
/* END: FINAL FIX FOR TABS */
        
        #libraryImportModal .library-tabs {
            width: 95%;
        }
        
        /* Modification to increase rule strength and make it customizable */
#libraryImportModal .library-search-input {
    width: 95%;
    padding: 12px;
    margin-top: 13px;
    margin-bottom: 13px;
    border: 1px solid var(--border-color);
    border-radius: 8px; 
    box-sizing: border-box;
}
        body.dark-mode .library-search-input {
            background-color: #3a3a3a;
            color: var(--text-color);
            border-color: #555;
        }
        
        .library-select {
    width: 100%;
    padding: 8px;
    font-size: 0.85em;
    line-height: 1.6;
}
        
        .format-options-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }
        .format-options-grid .modal-row {
            margin-bottom: 0;
            grid-column: 1 / -1;
        }
        
        @media (max-width: 600px) {
    h1.page-title {
        font-size: 1.9em;
    }

    .container {
        padding: 15px;
        margin: 10px auto;
    }
    table {
        font-size: 13.5px;
    }
    th {
        padding: 6px 3px;
        font-size: 13.5px;
    }
    td {
        padding: 14px 5px;
    }
    
    table th:nth-child(2), table td:nth-child(2) { 
        display: table-cell; 
    }

            .modal-content {
                width: 91%;
                padding: 15px;
                margin: auto;
                max-height: 90vh;
            }
            .modal-content input[type="text"],
            .modal-content input[type="url"],
            .modal-content input[type="number"] {
                margin: 5px 0 10px 0;
            }
            .find-replace-options {
                margin-top: 10px !important;
            }
            .find-replace-options p {
                margin-bottom: 2px;
            }
            #bulk-actions-list {
                gap: 8px;
            }
            .modal-buttons {
                margin-top: 15px;
            }
        }
        
        .site-footer {
            text-align: center;
            padding: 20px 20px 35px 20px;
            margin-top: auto;
            color: #888;
            font-size: 0.9em;
            flex-shrink: 0;
        }
        .site-footer a {
            color: var(--button-delete-color);
            text-decoration: none;
            font-weight: bold;
        }
        body.dark-mode .site-footer a {
            color: var(--primary-color);
        }
        .site-footer a:hover {
            text-decoration: underline;
        }

        .modal.modal-medium-top,
        .modal.modal-small-top {
            align-items: flex-start;
        }
        .modal.modal-medium-top .modal-content {
            margin-top: 100px;
        }
        .modal.modal-small-top .modal-content {
            margin-top: 150px;
        }

        #initialButtonsRow {
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #initialButtonsRow .action-btn {
            width: 100%;
            margin: 0;
        }
    #libraryImportModal h2 {
    color: #333333;
}

body.dark-mode #libraryImportModal h2 {
    color: var(--text-color);
}

    .sort-options-container {
        display: flex;
        justify-content: flex-start;
        align-items: center;
        gap: 25px;
        margin-top: 10px;
        padding-top: 15px;
        border-top: 1px solid var(--border-color);
        margin-bottom: 20px;
    }
    .sort-options-container .modal-row {
        margin-bottom: 0;
    }
    /* Add this code at the beginning of the <style> section */
#mainControls #uploadArea, 
#mainControls #urlLoadContainer, 
#mainControls #toolsMergeRow {
    display: none;
}
/* Adjust height and font size of scope list in Data Format modal only */
#formatDataModal #format-scope-selector {
    padding: 8.5px;
    font-size: 0.9em;
}
/* Adjust height and font size of scope list in Sort & Order modal */
#sortModal #sort-scope-selector {
    padding: 8px;
    font-size: 0.9em;
}
/* Adjust height and font size of "Select Group" list in Manage Groups modal */
#manageGroupsModal #groupSelector {
    padding: 8px;
    font-size: 0.9em;
}
/* Adjust height and font size of scope list in Find & Replace modal */
#findReplaceModal #replace-scope-selector {
    padding: 8px !important;
    font-size: 0.9em !important;
}

/* --- New Badge Styles --- */
#bulkActionsButton {
    position: relative;
    overflow: visible; 
}

.badge {
    position: absolute;
    top: -8px;    
    right: -8px; /* MODIFIED */
    left: auto;
    background-color: var(--primary-color);
    color: white;
    font-weight: bold;
    font-size: 12px;
    border-radius: 50%;
    width: 22px;
    height: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    
    transform: scale(0);
    opacity: 0;
    transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s;
}

.badge.visible {
    transform: scale(1);
    opacity: 1;
}

/* --- START: New styles for scrollable duplicate results --- */

#removeDuplicatesModal .modal-content {
    display: flex;
    flex-direction: column;
}

#duplicate-results-step {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    min-height: 0; 
}

#duplicate-results-list {
    overflow-y: auto;
    flex-grow: 1;
    padding: 10px 5px; 
    margin-top: 3px;
    margin-bottom: 15px;

    /* --- START: CODE TO HIDE THE SCROLLBAR --- */
    /* For Firefox */
    scrollbar-width: none;
    /* For Internet Explorer and Edge */
    -ms-overflow-style: none;  
}

/* For Chrome, Safari, and Opera */
#duplicate-results-list::-webkit-scrollbar {
    display: none;
}
/* --- END: CODE TO HIDE THE SCROLLBAR --- */

#duplicate-results-step > p,
#duplicate-results-step > .modal-buttons {
    flex-shrink: 0;
}
/* --- END: New styles for scrollable duplicate results --- */
/* --- START: MODIFICATION TO REDUCE TITLE SPACING --- */
.modal-content h2 {
    text-align: left; /* MODIFIED */
    margin-top: 5px;
    margin-bottom: 0px;
}
/* --- END: MODIFICATION --- */
/* --- Rule to Remove Tap Highlight Globally --- */
* {
    -webkit-tap-highlight-color: transparent !important;
}
/* --- Final fix for custom select arrow (CSS only) --- */

/* Target all select lists inside modals */
.modal-content select {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 10px center; /* MODIFIED */
    background-size: 1.2em;
    padding-right: 35px !important; /* MODIFIED */
    padding-left: 9px !important;
}

/* Adjust arrow color for dark mode */
body.dark-mode .modal-content select {
     background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23FFFFFF' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
}
/* --- START: Added space in Sort Modal --- */
#sortModal #sort-scope-container {
    margin-top: 14px;
}
/* --- END: Added space in Sort Modal --- */
/* --- START: Added space in Bulk Actions Modal --- */
#bulkActionsModal #bulk-actions-list {
    margin-top: 15px;
}
/* --- END: Added space in Bulk Actions Modal --- */
/* --- START: Added space in Remove Duplicates Modal --- */
#removeDuplicatesModal #duplicate-criteria-step {
    margin-top: 13px;
}
/* --- END: Added space in Remove Duplicates Modal --- */
/* --- START: Added space after Duplicate Criteria Label --- */
#removeDuplicatesModal #duplicate-criteria-step > label {
    display: block;
    margin-bottom: 10px;
    font-size: 1.1em;
}
/* --- END: Added space after Duplicate Criteria Label --- */
/* --- START: Added space in Format Data Modal --- */
#formatDataModal h2 {
    margin-bottom: 10px;
}
/* --- END: Added space in Format Data Modal --- */

#remove-words-container {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease-in-out, margin-top 0.3s ease-in-out;
    margin-top: 0;
}
#remove-words-container.visible {
    max-height: 100px;
    margin-top: 10px;
}
#bulk-edit-group-container {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease-in-out, margin-top 0.3s ease-in-out;
    margin-top: 0;
    width: 100%;
    padding-left: 25px; /* MODIFIED */
    padding-right: 0;
}
#bulk-edit-group-container.visible {
    max-height: 100px;
    margin-top: 10px;
}
h1.page-title {
    color: var(--primary-color);
    margin-top: 32px; /* <-- أضف هذا السطر */
}
#bulk-new-group-name {
    width: 100%;
    margin: 0;
    padding: 9px 9px;
}
/* --- START: Fix for Merge URL Textarea Width --- */
.merge-option-container {
    padding-left: 0;
    padding-right: 0;
}

#mergeUrlTextarea {
    width: calc(100% - 2px);
    display: block;
    margin-left: auto;
    margin-right: auto;
}
/* --- END: Fix for Merge URL Textarea Width --- */
/* --- START: Fix Vertical Spacing in Format Modal --- */

/* 1. Remove excess bottom padding from tab container */
#formatDataModal .format-tab-pane.active {
    padding-bottom: 14px;
}

/* 2. Set appropriate top margin for buttons */
#formatDataModal .modal-buttons {
    margin-top: 20px;
}

/* --- END: Fix Vertical Spacing in Format Modal --- */
/* --- START: Added space under Search & Filter Modal title --- */
#searchFilterModal h2 {
    margin-bottom: 20px;
}
/* --- END: Added space under Search & Filter Modal title --- */
/* --- START: Added space under Manage Groups Modal title --- */
#manageGroupsModal h2 {
    margin-bottom: 20px;
}
/* --- END: Added space under Manage Groups Modal title --- */
/* --- START: Added space under Sort & Order Modal title --- */
#sortModal h2 {
    margin-bottom: 25px;
}
/* --- END: Added space under Sort & Order Modal title --- */
/* --- START: Added space under Export Playlist Modal title --- */
#exportModal h2 {
    margin-bottom: 25px;
}
/* --- END: Added space under Export Playlist Modal title --- */
/* --- START: Added space under Remove Duplicates Modal title --- */
#removeDuplicatesModal h2 {
    margin-bottom: 15px;
}
/* --- END: Added space under Remove Duplicates Modal title --- */
/* --- START: Added space under Merge Options Modal title --- */
#mergeModal h2 {
    margin-bottom: 25px;
}
/* --- END: Added space under Merge Options Modal title --- */
/* --- START: Added space under Channel Status Checker Modal title --- */
#channelCheckerModal h2 {
    margin-bottom: 25px;
}
/* --- END: Added space under Channel Status Checker Modal title --- */
/* --- START: Added space in Format Data Modal --- */
#formatDataModal h2 {
    margin-bottom: 25px; /* <--- قم بتعديل هذه القيمة */
}
/* --- END: Added space in Format Data Modal --- */
/* --- START: Added space under Import from iptv-org Modal title --- */
#libraryImportModal h2 {
    margin-bottom: 25px;
}
/* --- END: Added space under Import from iptv-org Modal title --- */
/* --- START: Added space under Load from Multiple URLs Modal title --- */
#multiUrlModal h2 {
    margin-bottom: 35px;
}
/* --- END: Added space under Load from Multiple URLs Modal title --- */
/* --- START: Language Switcher Link Style (for LTR) --- */
#language-switcher {
    position: absolute;
    top: 11px;
    left: 11px; /* <-- التغيير هنا: أصبح على اليسار */
    right: auto; /* <-- إضافة هذا السطر لضمان عدم التعارض */
    
    color: #e0e0e0; 
    font-size: 0.85em;
    font-weight: bold;
    text-decoration: none;
    transition: opacity 0.2s;
    z-index: 10;
}

#language-switcher:hover {
    opacity: 0.8;
}

/* تعديل اللون ليتناسب مع الوضع الليلي */
body.dark-mode #language-switcher {
    color: #EAEAEA;
}
/* --- END: Language Switcher Link Style (for LTR) --- */
</style>
</head>
<body>
    <div class="container">
        <a href="/m3u-editor/" id="language-switcher">AR</a>
        <button id="theme-toggle" title="Toggle Mode">
            <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2.25a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0v-1.5A.75.75 0 0 1 12 2.25Zm0 18a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0v-1.5a.75.75 0 0 1 .75-.75ZM5.336 5.336a.75.75 0 0 1 1.06-1.06l1.06 1.06a.75.75 0 0 1-1.06 1.06l-1.06-1.06Zm12.268 12.268a.75.75 0 0 1 1.06-1.06l1.06 1.06a.75.75 0 0 1-1.06 1.06l-1.06-1.06ZM2.25 12a.75.75 0 0 1 .75-.75h1.5a.75.75 0 0 1 0 1.5h-1.5a.75.75 0 0 1-.75-.75Zm18 0a.75.75 0 0 1 .75-.75h1.5a.75.75 0 0 1 0 1.5h-1.5a.75.75 0 0 1-.75-.75ZM5.336 18.664a.75.75 0 0 1-1.06 1.06l-1.06-1.06a.75.75 0 0 1 1.06-1.06l1.06 1.06Zm12.268-12.268a.75.75 0 0 1-1.06 1.06l-1.06-1.06a.75.75 0 1 1 1.06-1.06l1.06 1.06ZM12 7a5 5 0 1 0 0 10 5 5 0 0 0 0-10Z"/></svg>
           <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
    <path d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z" />
</svg>
        </button>

        <h1 class="page-title">M3U Editor</h1>
        
        <div id="loadingIndicator" style="display: none;"><p>Loading...</p></div>
        
        <div id="mainControls">
            <label for="fileInput" id="uploadArea" class="upload-area">
                <p style="font-size: 1.1em; font-weight: bold;">Click to upload a playlist file</p>
                <span class="upload-label">Choose M3U, M3U8, PLS File</span>
            </label>
            
            <div id="urlLoadContainer">
                 <div class="button-row" id="initialButtonsRow">
                    <button class="action-btn" id="loadUrlButton" onclick="openModal('multiUrlModal')">Load from URLs</button>
                    <button class="action-btn" id="createNewPlaylistButton" onclick="createNewPlaylist()">Create New Playlist</button>
                 </div>
            </div>
            
            <div class="button-row" id="toolsMergeRow">
                <button class="action-btn" onclick="openModal('exportModal')">Export Playlist</button>
                <button class="action-btn" id="manageGroupsButton" onclick="openManageGroupsModal()">Manage Groups</button>
                <button class="action-btn" id="openSortModalButton" onclick="openSortModal()">Sort & Order</button>
                <button class="action-btn" id="advancedToolsButton" onclick="openModal('advancedOptionsModal')">Advanced Tools</button>
                <button class="action-btn" id="openSearchFilterModalButton" onclick="handleFilterButtonClick()">Search & Filter</button>
                <button class="action-btn" id="bulkActionsButton" onclick="openModal('bulkActionsModal')">
                    Bulk Actions
                    <span id="bulkActionsBadge" class="badge"></span>
                </button>
            </div>
        </div>

        <input type="file" id="fileInput" accept=".m3u,.m3u8,.pls,.json,.csv" multiple style="display: none;">
        <input type="file" id="mergeFileInput" accept=".m3u,.m3u8,.pls,.json,.csv" multiple style="display: none;">
        <div id="results"></div>
        <div id="paginationControls"></div>
    </div>

    <!-- All Modals -->
    <div id="dragDropChoiceModal" class="modal modal-small-top"><div class="modal-content"><span class="close" onclick="cancelDragOperation()">&times;</span><h2>How do you want to apply the order?</h2><div style="margin: 20px 0;"><div class="modal-row"><input type="radio" id="dragChoiceGroup" name="dragDropChoice" value="group" checked><label for="dragChoiceGroup">Group and reorder within results</label></div><div class="modal-row"><input type="radio" id="dragChoiceInPlace" name="dragDropChoice" value="sortInPlace"><label for="dragChoiceInPlace">Reorder in current positions only</label></div></div><div class="modal-buttons"><button id="executeDragDropChoice">Execute</button><button class="cancel" onclick="cancelDragOperation()">Cancel</button></div></div></div>
    <div id="searchFilterModal" class="modal modal-small-top"><div class="modal-content"><span class="close" onclick="closeModal('searchFilterModal')">&times;</span><h2>Search & Filter Channels</h2><input type="text" id="searchInput" placeholder="Search for a channel..."><select id="groupFilter"><option value="all">All Groups</option></select><div class="modal-buttons"><button id="searchFilterActionButton">Apply Filter</button></div></div></div>
    <div id="bulkActionsModal" class="modal"><div class="modal-content"><span class="close" onclick="closeModal('bulkActionsModal')">&times;</span><h2>Actions on Selected Channels</h2><div id="bulk-actions-list"><div class="modal-row"><input type="radio" id="bulk-action-sort" name="bulkAction" value="sort" checked><label for="bulk-action-sort">Sort selected alphabetically</label></div><div class="modal-row"><input type="radio" id="bulk-action-move" name="bulkAction" value="move"><label for="bulk-action-move">Move selected to position</label><div id="bulk-move-input-container"><label for="bulk-move-target-index">No:</label><input type="number" id="bulk-move-target-index" min="1" placeholder="e.g., 1"></div></div><div class="modal-row"><input type="radio" id="bulk-action-group" name="bulkAction" value="group"><label for="bulk-action-group">Edit group</label><div id="bulk-edit-group-container"><input type="text" id="bulk-new-group-name" placeholder="Enter new group name"></div></div><div class="modal-row"><input type="radio" id="bulk-action-remove-group" name="bulkAction" value="removeGroup"><label for="bulk-action-remove-group">Remove group from selected</label></div><div class="modal-row"><input type="radio" id="bulk-action-delete" name="bulkAction" value="delete"><label for="bulk-action-delete">Delete selected</label></div><div class="modal-row"><input type="radio" id="bulk-action-export" name="bulkAction" value="export"><label for="bulk-action-export">Export selected</label></div></div><div class="modal-buttons"><button onclick="executeBulkAction()">Execute</button><button onclick="closeModal('bulkActionsModal')" class="cancel">Cancel</button></div></div></div>
    <div id="channelCheckerModal" class="modal modal-small-top"><div class="modal-content"><span class="close" onclick="closeModal('channelCheckerModal')">&times;</span><h2>Channel Status Checker</h2><p>This action will check each channel to determine if it's working. This might take some time for large playlists.</p><div id="checker-progress-container"><p id="checker-progress-text">Press 'Start Check' to verify channel statuses.</p><div id="checker-progress-bar-container"><div id="checker-progress-bar">0%</div></div></div><p id="checker-summary-text" style="font-weight: bold;"></p><div class="modal-buttons"><button id="start-check-btn" onclick="executeChannelCheck()">Start Check</button><button id="stop-check-btn" onclick="stopChannelCheck()" class="cancel" style="display:none;">Stop Check</button><button id="checker-cancel-btn" onclick="closeModal('channelCheckerModal')" class="cancel">Close</button></div><div class="dropdown-container" id="checker-actions-container" style="display: none;"><button onclick="toggleCheckerActions()" class="dropdown-btn">Actions &#9662;</button><div id="checker-actions-dropdown" class="dropdown-content"><a href="#" id="export-working-btn" onclick="exportWorkingChannels()">Export working channels</a><a href="#" id="select-failed-btn" onclick="selectFailedChannels()">Select non-working channels</a><a href="#" id="delete-failed-btn" class="delete-option" onclick="deleteFailedChannels()">Delete non-working channels</a></div></div></div></div>
    <div id="multiUrlModal" class="modal modal-medium-top"><div class="modal-content"><span class="close" onclick="closeModal('multiUrlModal')">&times;</span><h2>Load from Multiple URLs</h2><p>Paste URLs here, each on a new line. They will be merged in order.</p><textarea id="multiUrlTextarea" placeholder="https://example.com/playlist1.m3u&#10;https://example.com/playlist2.m3u8"></textarea><div class="modal-buttons"><button onclick="processMultiUrlLoad()">Load</button><button onclick="closeModal('multiUrlModal')" class="cancel">Cancel</button></div></div></div>
    <div id="editModal" class="modal modal-medium-top"><div class="modal-content"><span class="close" onclick="closeModal('editModal')">&times;</span><h2>Edit Channel</h2><div class="modal-form-row"><label for="editIndexField">Channel No:</label><input type="number" id="editIndexField" min="1"></div><div class="modal-form-row"><label for="editName">Channel Name:</label><input type="text" id="editName"></div><div class="modal-form-row"><label for="editGroup">Group:</label><input type="text" id="editGroup"></div><div class="modal-form-row"><label for="editLogo">Logo URL:</label><input type="url" id="editLogo"><div id="logoPreview"><img id="previewImage"></div></div><div class="modal-form-row"><label for="editUrl">Stream URL:</label><input type="url" id="editUrl"></div><input type="hidden" id="editOriginalIndex"><div class="modal-buttons"><button onclick="saveEdit()">Save</button><button onclick="closeModal('editModal')" class="cancel">Cancel</button></div></div></div>
    <div id="addModal" class="modal modal-medium-top"><div class="modal-content"><span class="close" onclick="closeModal('addModal')">&times;</span><h2>Add New Channel</h2><div class="modal-form-row"><label for="addIndexField">Channel No:</label><input type="number" id="addIndexField" min="1"></div><div class="modal-form-row"><label for="addName">Channel Name:</label><input type="text" id="addName" required></div><div class="modal-form-row"><label for="addGroup">Group:</label><input type="text" id="addGroup"></div><div class="modal-form-row"><label for="addLogo">Logo URL:</label><input type="url" id="addLogo"><div id="addLogoPreview"><img id="addPreviewImage"></div></div><div class="modal-form-row"><label for="addUrl">Stream URL:</label><input type="url" id="addUrl" required></div><div class="modal-buttons"><button onclick="saveNewChannel()">Add</button><button onclick="closeModal('addModal')" class="cancel">Cancel</button></div></div></div>
    <div id="removeDuplicatesModal" class="modal modal-small-top"><div class="modal-content"><span class="close" onclick="closeModal('removeDuplicatesModal')">&times;</span><h2>Remove Duplicates</h2><div id="duplicate-criteria-step"><label>Select criteria for finding duplicates:</label><div class="modal-row"><input type="radio" id="crit-name" name="duplicateCriteria" value="name"><label for="crit-name">Full Name Only</label></div><div class="modal-row"><input type="radio" id="crit-partial-name-url" name="duplicateCriteria" value="partial-name-url" checked><label for="crit-partial-name-url">Partial Name + URL (Strongest)</label></div><div class="modal-row"><input type="radio" id="crit-name-url" name="duplicateCriteria" value="name-url"><label for="crit-name-url">Full Name + URL</label></div><div class="modal-row"><input type="radio" id="crit-name-url-group" name="duplicateCriteria" value="name-url-group"><label for="crit-name-url-group">Full Name + URL + Group</label></div><div class="modal-buttons"><button onclick="findDuplicates()">Find Duplicates</button><button onclick="closeModal('removeDuplicatesModal')" class="cancel">Cancel</button></div></div><div id="duplicate-results-step" style="display: none;"><p><strong>Select the version you want to keep:</strong></p><div id="duplicate-results-list"></div><div class="modal-buttons"><button onclick="executeDuplicateDeletion()">Delete Duplicates</button><button onclick="showDuplicateCriteriaStep()" class="cancel">Back</button></div></div></div></div>
    <div id="sortModal" class="modal"><div class="modal-content"><span class="close" onclick="closeModal('sortModal')">&times;</span><h2>Sort & Order Channels</h2><div id="sort-scope-container" style="display: none; margin-bottom: 15px;"><label for="sort-scope-selector" style="display:block; margin-bottom: 5px;"><strong>Sort Scope:</strong></label><select id="sort-scope-selector" style="width: 100%;"></select></div><div class="modal-row"><input type="radio" id="sort-alpha" name="sortCriteria" value="alphabetical" checked onchange="handleSortCriteriaChange()"><label for="sort-alpha">Alphabetical</label></div><div class="modal-row"><input type="radio" id="sort-name" name="sortCriteria" value="name" onchange="handleSortCriteriaChange()"><label for="sort-name">By Channel Name</label></div><div id="sortByNameInputContainer"><input type="text" id="sortByNameField" placeholder="Enter channel name (e.g., ESPN)"></div><div class="modal-row"><input type="radio" id="sort-group" name="sortCriteria" value="group" onchange="handleSortCriteriaChange()"><label for="sort-group">By Group Name</label></div><div id="sortByGroupInputContainer"><input type="text" id="sortByGroupField" placeholder="Enter group name"></div><div class="modal-row" id="sort-move-row"><input type="radio" id="sort-move" name="sortCriteria" value="moveBlock" onchange="handleSortCriteriaChange()"><label id="sort-move-label" for="sort-move">Move channels to new position</label></div><div id="moveBlockInputContainer"><div id="moveBlockRangeContainer"><div class="move-block-row"><label for="moveFromIndex">Move from No:</label><input type="number" id="moveFromIndex" min="1" placeholder="e.g., 50"></div><div class="move-block-row"><label for="moveToIndex">To No:</label><input type="number" id="moveToIndex" min="1" placeholder="e.g., 100"></div></div><div class="move-block-row"><label for="moveTargetIndex">To Position No:</label><input type="number" id="moveTargetIndex" min="1" placeholder="e.g., 1"></div></div><div class="sort-options-container"><div class="modal-row"><input type="checkbox" id="sort-descending"><label for="sort-descending">Descending</label></div><div class="modal-row" id="sort-grouping-container"><input type="checkbox" id="sort-grouping"><label for="sort-grouping">Group together</label></div></div><div class="modal-buttons"><button onclick="executeSort()">Execute</button><button onclick="closeModal('sortModal')" class="cancel">Cancel</button></div></div></div>
    <div id="manageGroupsModal" class="modal"><div class="modal-content"><span class="close" onclick="closeModal('manageGroupsModal')">&times;</span><h2>Manage Groups</h2><div style="padding: 5px; margin: 0 -5px 15px -5px;"><label for="groupSelector">Select Group:</label><select id="groupSelector" onchange="handleGroupSelectorChange()"></select><label>Select Action:</label><div class="modal-row"><input type="radio" id="action-rename" name="groupAction" value="rename" checked onchange="handleGroupActionChange()"><label for="action-rename">Rename</label></div><div id="renameGroupInputContainer"><input type="text" id="newGroupNameField" placeholder="Enter new name or leave empty"><div class="modal-row" style="font-size: 0.9em; margin-top: 5px;"><input type="checkbox" id="rename-add-as-new"><label for="rename-add-as-new">Add without removing existing groups</label></div></div><div class="modal-row"><input type="radio" id="action-merge" name="groupAction" value="merge" onchange="handleGroupActionChange()"><label for="action-merge">Merge Selected Group</label></div><div id="mergeGroupInputContainer"><label for="mergeTargetSelector" style="display: block;">With Group:</label><select id="mergeTargetSelector"></select></div><div class="modal-row"><input type="radio" id="action-remove-all-groups" name="groupAction" value="removeAll" onchange="handleGroupActionChange()"><label for="action-remove-all-groups">Remove All Groups</label></div><div class="modal-row"><input type="radio" id="action-delete" name="groupAction" value="delete" onchange="handleGroupActionChange()"><label for="action-delete">Delete Group</label></div><div class="modal-row"><input type="radio" id="action-export-group" name="groupAction" value="exportGroup" onchange="handleGroupActionChange()"><label for="action-export-group">Export Group Channels</label></div></div><div class="modal-buttons"><button onclick="executeGroupAction()">Execute</button><button onclick="closeModal('manageGroupsModal')" class="cancel">Cancel</button></div></div></div>
    <div id="mergeModal" class="modal modal-small-top"><div class="modal-content"><span class="close" onclick="closeModal('mergeModal')">&times;</span><h2>Merge Options</h2><div class="modal-content-body"><label for="mergeOptionSelector" style="display:block; margin-bottom: 5px; text-align: left;">Select Merge Method:</label><select id="mergeOptionSelector" onchange="handleMergeOptionChange()"><option value="file" selected>From File</option><option value="url">From URL</option></select><div id="mergeFileOption" class="merge-option-container" style="display: block;"><p>Choose one or more files to merge with the current playlist.</p><button onclick="document.getElementById('mergeFileInput').click()">Choose Files</button></div><div id="mergeUrlOption" class="merge-option-container" style="display: none;"><p>Paste URLs here, each on a new line.</p><textarea id="mergeUrlTextarea" placeholder="https://example.com/playlist.m3u" style="min-height: 120px; margin-bottom: 20px; direction: ltr; text-align: left;"></textarea><button onclick="executeMerge()">Merge URLs</button></div></div></div></div>
    <div id="exportModal" class="modal modal-medium-top"><div class="modal-content"><span class="close" onclick="closeModal('exportModal')">&times;</span><h2>Export Playlist</h2><p>Choose the desired format for saving:</p><div class="modal-row"><input type="radio" id="export-m3u" name="exportFormat" value="m3u" checked><label for="export-m3u">M3U</label></div><div class="modal-row"><input type="radio" id="export-m3u8" name="exportFormat" value="m3u8"><label for="export-m3u8">M3U8</label></div><div class="modal-row"><input type="radio" id="export-pls" name="exportFormat" value="pls"><label for="export-pls">PLS</label></div><div class="modal-row"><input type="radio" id="export-json" name="exportFormat" value="json"><label for="export-json">JSON</label></div><div class="modal-row"><input type="radio" id="export-csv" name="exportFormat" value="csv"><label for="export-csv">CSV</label></div><div class="modal-row"><input type="radio" id="export-enigma2" name="exportFormat" value="enigma2"><label for="export-enigma2">Enigma2</label></div><div class="modal-buttons"><button onclick="executeExport()">Export</button><button onclick="closeModal('exportModal')" class="cancel">Cancel</button></div></div></div>
    <div id="confirmModal" class="modal modal-small-top"><div class="modal-content"><span class="close" onclick="closeModal('confirmModal')">&times;</span><h2 id="confirmTitle">Confirm Action</h2><p id="confirmMessage">Are you sure?</p><div class="modal-buttons"><button id="confirmBtn" class="action-btn">Confirm</button><button onclick="closeModal('confirmModal')" class="action-btn delete-btn">Cancel</button></div></div></div>
    <div id="toastContainer"></div>

    <div id="video-popup" class="popup">
        <div class="popup-content" id="popup-content">
            <div id="player-container"></div>
        </div>
    </div>
    
    <!-- Modal for Advanced Options -->
    <div id="advancedOptionsModal" class="modal modal-medium-top">
        <div class="modal-content">
            <span class="close" onclick="closeModal('advancedOptionsModal')">&times;</span>
            <h2>Advanced Tools</h2>
            <div id="modal-options-list">
                <button onclick="startNewSession()">Start New</button>
                <button onclick="openAddModal(); closeModal('advancedOptionsModal');">Add Channel</button>
                <button onclick="openMergeModal(); closeModal('advancedOptionsModal');">Merge Playlists</button>
                <button onclick="removeDuplicatesManually(); closeModal('advancedOptionsModal');">Remove Duplicates</button>
                <button onclick="handleChannelCheckClick(); closeModal('advancedOptionsModal');">Check Ch. Status</button>
                <button onclick="openFormatDataModal(); closeModal('advancedOptionsModal');">Format Data</button>
                <button onclick="openLibraryImportModal(); closeModal('advancedOptionsModal');">Import from iptv-org</button>
                <button id="modalPlayModeToggle" onclick="togglePlayMode(); closeModal('advancedOptionsModal');">Enable Play Mode</button>
            </div>
        </div>
    </div>
    
    <!-- Modal for Library Import -->
    <div id="libraryImportModal" class="modal modal-medium-top">
        <div class="modal-content">
            <span class="close" onclick="closeModal('libraryImportModal')">&times;</span>
            <h2>Import from iptv-org</h2>
            <p>Choose a category then select the desired list.</p>
            
            <!-- Tab buttons -->
            <div class="library-tabs">
                <button class="library-tab-btn active" onclick="openLibraryTab(event, 'Country')" id="defaultOpenTab">By Country</button>
                <button class="library-tab-btn" onclick="openLibraryTab(event, 'Language')">By Language</button>
                <button class="library-tab-btn" onclick="openLibraryTab(event, 'Category')">By Category</button>
            </div>

            <div id="library-loading-indicator" style="text-align: center; margin: 20px 0;">Fetching lists...</div>

            <!-- Tab content -->
            <div id="Country" class="library-tab-pane" style="display: block;">
                <input type="text" id="countrySearchInput" class="library-search-input" placeholder="Search for a country...">
                <select id="libraryCountryFilter" class="library-select" size="8">
                    <option value="">-- Select a country --</option>
                </select>
            </div>
            <div id="Language" class="library-tab-pane">
                <input type="text" id="languageSearchInput" class="library-search-input" placeholder="Search for a language...">
                <select id="libraryLanguageFilter" class="library-select" size="8">
                    <option value="">-- Select a language --</option>
                </select>
            </div>
            <div id="Category" class="library-tab-pane">
                <input type="text" id="categorySearchInput" class="library-search-input" placeholder="Search for a category...">
                <select id="libraryCategoryFilter" class="library-select" size="8">
                    <option value="">-- Select a category --</option>
                </select>
            </div>

            <div style="margin-top: 11px; margin-bottom: 24px;">
                <div class="modal-row" style="justify-content: flex-start; gap: 30px;">
                    <label for="import-action-merge" style="display: flex; align-items: center; cursor: pointer; margin: 0;"><input type="radio" id="import-action-merge" name="importAction" value="merge" checked style="margin: 0 5px 0 0;">Merge with current</label>
                    <label for="import-action-replace" style="display: flex; align-items: center; cursor: pointer; margin: 0;"><input type="radio" id="import-action-replace" name="importAction" value="replace" style="margin: 0 5px 0 0;">Replace current</label>
                </div>
            </div>

            <div class="modal-buttons">
                <button onclick="executeLibraryImport()">Import</button>
                <button class="cancel" onclick="closeModal('libraryImportModal')">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Modal for Data Formatting -->
    <div id="formatDataModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('formatDataModal')">&times;</span>
            <h2>Format Data</h2>
            
            <div style="margin-bottom: 15px;">
                <label for="format-scope-selector" style="display:block; margin-bottom: 5px;"><strong>Apply to:</strong></label>
                <select id="format-scope-selector" style="width: 100%;"></select>
            </div>

            <div class="format-container">
                <!-- Tab buttons -->
                <div class="format-tabs">
                    <button class="format-tab-btn" onclick="openFormatTab(event, 'FormatCase')" id="defaultFormatOpen">Casing</button>
                    <button class="format-tab-btn" onclick="openFormatTab(event, 'FormatAffix')">Affixes</button>
                    <button class="format-tab-btn" onclick="openFormatTab(event, 'FormatReplace')">Replace</button>
                    <button class="format-tab-btn" onclick="openFormatTab(event, 'FormatClean')">Clean</button>
                </div>
                
                <!-- Tab content -->
                <div id="FormatCase" class="format-tab-pane">
                     <div class="format-options-grid">
                        <div class="modal-row"><input type="radio" id="case-none" name="formatCase" value="none" checked><label for="case-none">No change</label></div>
                        <div class="modal-row"><input type="radio" id="case-upper" name="formatCase" value="upper"><label for="case-upper">UPPERCASE</label></div>
                        <div class="modal-row"><input type="radio" id="case-lower" name="formatCase" value="lower"><label for="case-lower">lowercase</label></div>
                        <div class="modal-row"><input type="radio" id="case-title" name="formatCase" value="title"><label for="case-title">Title Case</label></div>
                    </div>
                    <div id="title-case-exceptions-container" style="display: none; margin-top: 10px; width: 100%;">
                        <input type="text" id="title-case-exceptions-input" placeholder="Exceptions: TV, HD, OSN (comma-separated)" style="width: 100%;">
                    </div>
                </div>
                <div id="FormatAffix" class="format-tab-pane">
                    <label for="format-prefix">Add as prefix:</label>
                    <input type="text" id="format-prefix" placeholder="e.g., VIP" style="width: 100%;">
                    <label for="format-suffix">Add as suffix:</label>
                    <input type="text" id="format-suffix" placeholder="e.g., FHD" style="width: 100%;">
                </div>
                <div id="FormatReplace" class="format-tab-pane">
                    <label for="find-text">Find:</label>
                    <input type="text" id="find-text" style="width: 100%;">
                    <label for="replace-text" style="margin-top:10px; display:block;">Replace with:</label>
                    <input type="text" id="replace-text" style="width: 100%;">
                    <div class="find-replace-options">
                        <p style="margin-top: 15px; margin-bottom: 5px;"><strong>Search in:</strong></p>
                        <div><input type="checkbox" id="find-in-name" checked> <label for="find-in-name">Channel Name</label></div>
                        <div><input type="checkbox" id="find-in-group"> <label for="find-in-group">Group</label></div>
                        <div><input type="checkbox" id="find-in-url"> <label for="find-in-url">Stream URL</label></div>
                    </div>
                </div>
                <div id="FormatClean" class="format-tab-pane">
                     <div class="format-options-grid">
                        <div class="modal-row"><input type="checkbox" id="format-trim" checked><label for="format-trim">Trim extra whitespace</label></div>
                        <div class="modal-row"><input type="checkbox" id="format-remove-logos"><label for="format-remove-logos">Remove all logos</label></div>
                        <div class="modal-row">
                            <input type="checkbox" id="format-remove-words-toggle" onchange="document.getElementById('remove-words-container').classList.toggle('visible', this.checked)">
                            <label for="format-remove-words-toggle">Remove specific words</label>
                        </div>
                    </div>
                    <div id="remove-words-container">
                        <textarea id="format-remove-words-input" placeholder="Enter words here, comma-separated (e.g., 1080p, VIP, (US))" style="width: 100%; min-height: 80px; direction: ltr; text-align: left;"></textarea>
                    </div>
                </div>
            </div>


            <div class="modal-buttons">
                <button onclick="executeFormatting()">Execute</button>
                <button class="cancel" onclick="closeModal('formatDataModal')">Cancel</button>
            </div>
        </div>
    </div>


    <footer class="site-footer">
        <p>Developed by <a href="https://github.com/iofahmawi" target="_blank" rel="noopener noreferrer">iofahmawi</a></p>
    </footer>

    <script src="https://cdn.plyr.io/3.7.8/plyr.js"></script>

    <script>
        let channelsData = []; let displayedChannels = []; let isMerged = false, isSorted = false; let draggedIndices = []; let selectedIndices = new Set(); let currentPage = 1; const rowsPerPage = 100; let isChecking = false; let isFilterActiveForButton = false;
        let filterDragMode = null;
        let latestDropTargetRow = null;
        let isPlayMode = false;
        let player;
        let hls;
        let isCheckPerformed = false;
        
        // START: Added for debouncing library filter
        let debounceTimeout = null;
        let isLibraryDataFetched = false;
        // END: Added for debouncing library filter
        
        // START: Undo Manager
        const undoManager = {
            previousState: null,
            undoTimeout: null,
            isUndoInProgress: false,

            registerUndo: function() {
                this.clearUndo();
                this.previousState = JSON.stringify(channelsData);
                this.undoTimeout = setTimeout(() => {
                    this.clearUndo();
                }, 8000); // 8 second window to undo
            },

            performUndo: function() {
                if (this.previousState && !this.isUndoInProgress) {
                    this.isUndoInProgress = true;
                    clearTimeout(this.undoTimeout);
                    
                    channelsData = JSON.parse(this.previousState);
                    this.previousState = null;
                    this.undoTimeout = null;

                    updateAndRefreshUI();
                    showToast('Action undone.', 'info');
                    
                    setTimeout(() => { this.isUndoInProgress = false; }, 500);
                }
            },

            clearUndo: function() {
                if (this.previousState) {
                    clearTimeout(this.undoTimeout);
                    this.previousState = null;
                    this.undoTimeout = null;
                }
            }
        };
        // END: Undo Manager

        function generateCountString(count, words) {
            if (count === 1) {
                return `1 ${words.singular}`;
            }
            return `${count} ${words.plural}`;
        }

        function saveSession() {
            try {
                if (channelsData.length > 0) {
                    localStorage.setItem('m3uEditorSession', JSON.stringify(channelsData));
                } else {
                    localStorage.removeItem('m3uEditorSession');
                }
            } catch (e) {
                console.error("Failed to save session:", e);
                showToast("Error: Could not save your session. Storage might be full.", "error");
            }
        }

        function loadSession() {
            try {
                const savedData = localStorage.getItem('m3uEditorSession');
                if (savedData) {
                    channelsData = JSON.parse(savedData);
                    if (channelsData.length > 0) {
                        showPlaylistControls();
                        updateAndRefreshUI();
                        
                        const action = {
                            text: 'here',
                            callback: () => {
                                localStorage.removeItem('m3uEditorSession');
                                location.reload();
                            }
                        };
                        showToast('To start a new session, click', 'info', -1, action);
                    }
                }
            } catch (e) {
                console.error("Failed to load session:", e);
                localStorage.removeItem('m3uEditorSession');
            }
        }
        
        function openModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.zIndex = '2000';
                modal.style.display = 'flex';
            }
            
            if (modalId === 'searchFilterModal') {
                setupSearchFilterModal();
            } else if (modalId === 'bulkActionsModal') {
                document.querySelectorAll('input[name="bulkAction"]').forEach(radio => {
                    radio.onchange = handleBulkActionChange;
                });
                handleBulkActionChange();
            } else if (modalId === 'removeDuplicatesModal') {
                showDuplicateCriteriaStep();
            }
        }

        function closeModal(modalId) { 
            if(modalId === 'channelCheckerModal' && isChecking) { stopChannelCheck(); } 
            
            const modal = document.getElementById(modalId); 
            if(modal) modal.style.display = 'none'; 
            
            if (modalId === 'editModal' && document.getElementById('removeDuplicatesModal').style.display === 'flex') {
                document.getElementById('removeDuplicatesModal').style.zIndex = '2000';
            }
        }

        function handleDragStart(e) {
            e.currentTarget.style.cursor = 'grabbing';
            const startIndex = parseInt(e.currentTarget.dataset.index);
            if (selectedIndices.has(startIndex)) {
                draggedIndices = Array.from(selectedIndices).sort((a, b) => a - b);
            } else {
                selectedIndices.clear();
                selectedIndices.add(startIndex);
                document.querySelectorAll('tr.selected').forEach(row => row.classList.remove('selected'));
                e.currentTarget.classList.add('selected');
                updateBulkActionsUI();
            }
            draggedIndices = Array.from(selectedIndices).sort((a, b) => a - b);
            document.body.classList.add('is-dragging');
        }

        function handleDragEnd(e) {
            document.body.classList.remove('is-dragging');
        }
        
        function handleDragEnter(e) { e.preventDefault(); const targetRow = e.currentTarget; const targetIndex = parseInt(targetRow.dataset.index); if (!draggedIndices.includes(targetIndex)) { targetRow.classList.add('drag-over-indicator'); } }
        function handleDragLeave(e) { e.currentTarget.classList.remove('drag-over-indicator'); }
        function handleDragOver(e) { e.preventDefault(); }
        
        function handleDrop(e) {
            e.preventDefault();
            const isFilterActive = document.getElementById('searchInput').value !== '' || document.getElementById('groupFilter').value !== 'all';
            
            if (!isFilterActive) {
                performDrop('sortInPlace', e.currentTarget);
            } else {
                if (filterDragMode === null) {
                    latestDropTargetRow = e.currentTarget;
                    openModal('dragDropChoiceModal');
                } else {
                    performDrop(filterDragMode, e.currentTarget);
                }
            }
        }

        function performDrop(mode, dropTargetRow) {
            dropTargetRow.classList.remove('drag-over-indicator');
            const dropIndexInFullList = parseInt(dropTargetRow.dataset.index);

            if (draggedIndices.length === 0 || draggedIndices.includes(dropIndexInFullList)) {
                draggedIndices = [];
                return;
            }

            const draggedChannels = draggedIndices.map(i => channelsData[i]);

            if (mode === 'group') {
                const remainingDisplayed = displayedChannels.filter(c => !draggedChannels.includes(c));
                const dropTargetChannel = channelsData[dropIndexInFullList];
                let insertionIndex = remainingDisplayed.indexOf(dropTargetChannel);
                const isDraggingDown = displayedChannels.indexOf(draggedChannels[0]) < displayedChannels.indexOf(dropTargetChannel);
                if (isDraggingDown && insertionIndex !== -1) insertionIndex++;
                if (insertionIndex === -1) insertionIndex = remainingDisplayed.length;

                remainingDisplayed.splice(insertionIndex, 0, ...draggedChannels);
                const newOrderedFilteredChannels = remainingDisplayed;
                
                const originalFilteredChannelsSet = new Set(displayedChannels);
                const firstOriginalIndex = channelsData.findIndex(ch => originalFilteredChannelsSet.has(ch));
                
                if (firstOriginalIndex > -1) {
                    const mainListWithoutFiltered = channelsData.filter(ch => !originalFilteredChannelsSet.has(ch));
                    mainListWithoutFiltered.splice(firstOriginalIndex, 0, ...newOrderedFilteredChannels);
                    channelsData = mainListWithoutFiltered;
                }
            } else { // mode === 'sortInPlace'
                const tempChannelList = [...channelsData];
                
                draggedIndices.sort((a,b)=>b-a).forEach(index => tempChannelList.splice(index, 1));

                let newDropIndex = tempChannelList.findIndex(ch => ch === channelsData[dropIndexInFullList]);
                const isDraggingDown = draggedIndices[0] < dropIndexInFullList;

                if (isDraggingDown) {
                    newDropIndex++;
                }
                
                tempChannelList.splice(newDropIndex, 0, ...draggedChannels);
                channelsData = tempChannelList;
            }

            draggedIndices = [];
            selectedIndices.clear();
            updateAndRefreshUI();
        }

        function setupPopupDrag() {
            const popup = document.getElementById('video-popup');
            const popupContent = document.getElementById('popup-content');
            
            let isDragging = false;
            let startY;
            let currentTranslateY = 0;

            const dragStart = (e) => {
                if (e.target.closest('.plyr__controls')) return;
                isDragging = true;
                startY = e.pageY || e.touches[0].pageY;
                popupContent.classList.add('dragging');
            };

            const dragMove = (e) => {
                if (!isDragging) return;
                e.preventDefault();
                const currentY = e.pageY || e.touches[0].pageY;
                const deltaY = currentY - startY;
                const newTranslateY = currentTranslateY + deltaY;
                popupContent.style.transform = `translateY(${newTranslateY}px)`;
            };

            const dragEnd = (e) => {
                if (!isDragging) return;
                isDragging = false;
                popupContent.classList.remove('dragging');
                const currentY = e.pageY || e.changedTouches[0].pageY;
                currentTranslateY += (currentY - startY);
            };

            popupContent.addEventListener('mousedown', dragStart);
            popupContent.addEventListener('touchstart', dragStart, { passive: false });
            document.addEventListener('mousemove', dragMove);
            document.addEventListener('touchmove', dragMove, { passive: false });
            document.addEventListener('mouseup', dragEnd);
            document.addEventListener('touchend', dragEnd);

            popup.addEventListener('click', (event) => {
                if (event.target === popup) stopPlayer(false);
            });
        }
        
        function clearAllSelections() {
            if (selectedIndices.size > 0) {
                selectedIndices.clear();
                updateAndRefreshUI();
            }
        }

        document.addEventListener('DOMContentLoaded', () => { 
            document.getElementById('executeDragDropChoice').onclick = () => {
                const selectedMode = document.querySelector('input[name="dragDropChoice"]:checked').value;
                filterDragMode = selectedMode;
                if (latestDropTargetRow) {
                    performDrop(filterDragMode, latestDropTargetRow);
                }
                closeModal('dragDropChoiceModal');
                latestDropTargetRow = null;
            };

            loadSession();
            if(channelsData.length === 0) {
                resetToInitialView();
            }
            
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    clearAllSelections();
                }
            });

            document.querySelector('.container').addEventListener('click', (event) => {
                // Do nothing if a modal is open
                if (document.querySelector('.modal[style*="display: flex"]')) return;
                
                // Check if the click is on a non-interactive part of the container
                if (!event.target.closest('table, .action-btn, input, select, button, a, .upload-area')) {
                     clearAllSelections();
                }
            });
            
            setupPopupDrag();
        });

        function cancelDragOperation() {
            draggedIndices = [];
            latestDropTargetRow = null;
            closeModal('dragDropChoiceModal');
            displayPaginatedChannels();
        }

        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
        document.getElementById('mergeFileInput').addEventListener('change', mergePlaylists);
        
        function showToast(message, type = 'info', duration = 6000, action = null) {
            const container = document.getElementById('toastContainer');
            const toastWrapper = document.createElement('div');
            toastWrapper.className = 'toast-wrapper';
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            let contentHTML = '';
            if (action) {
                contentHTML = `<div class="toast-content" style="white-space: normal;">${message} <span class="toast-action" style="margin-left: 5px;">${action.text}</span></div>`;
            } else {
                const cleanMessage = message.trim().replace(/\.$/, '');
                contentHTML = `<div class="toast-content">${cleanMessage}</div>`;
            }
            
            contentHTML += `<button class="toast-close">&times;</button>`;
            toast.innerHTML = contentHTML;

            toastWrapper.appendChild(toast);
            container.appendChild(toastWrapper);

            const removeToast = () => {
                toastWrapper.classList.remove('show');
                setTimeout(() => {
                    if (container.contains(toastWrapper)) container.removeChild(toastWrapper);
                }, 500);
            };

            if (action) {
                const actionButton = toast.querySelector('.toast-action');
                if (actionButton) {
                    actionButton.onclick = (e) => {
                        e.stopPropagation();
                        action.callback();
                        removeToast();
                    };
                }
            }
            
            const closeButton = toast.querySelector('.toast-close');
            closeButton.onclick = removeToast;

            if (duration !== -1) {
                setTimeout(removeToast, duration);
            }

            setTimeout(() => toastWrapper.classList.add('show'), 10);
        }

        function showConfirm(title, message, onConfirm) { document.getElementById('confirmTitle').textContent = title; document.getElementById('confirmMessage').textContent = message; const confirmBtn = document.getElementById('confirmBtn'); const newConfirmBtn = confirmBtn.cloneNode(true); confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn); newConfirmBtn.onclick = () => { onConfirm(); closeModal('confirmModal'); }; openModal('confirmModal'); }
        function handleRowClick(event) { const row = event.currentTarget; if (event.target.closest('img, .placeholder, .play-btn-icon')) return; const index = parseInt(row.dataset.index); if (selectedIndices.has(index)) { selectedIndices.delete(index); row.classList.remove('selected'); } else { selectedIndices.add(index); row.classList.add('selected'); } updateBulkActionsUI(); }
        
        function updateBulkActionsUI() {
            const bulkActionsButton = document.getElementById('bulkActionsButton');
            const badge = document.getElementById('bulkActionsBadge'); 
            const count = selectedIndices.size;

            bulkActionsButton.disabled = count === 0;

            if (count > 0) {
                badge.textContent = count;
                badge.classList.add('visible');
            } else {
                badge.classList.remove('visible');
            }
        }

        function deleteSelected() {
            const count = selectedIndices.size;
            if (count === 0) return;

            undoManager.registerUndo();

            const indicesToDelete = Array.from(selectedIndices).sort((a, b) => b - a);
            indicesToDelete.forEach(index => {
                channelsData.splice(index, 1);
            });
            
            selectedIndices.clear();
            updateAndRefreshUI();
            
            const countStr = generateCountString(count, {singular: 'channel', plural: 'channels'});
            showToast(`Deleted ${countStr}.`, 'success', 8000, {
                text: 'Undo',
                callback: () => undoManager.performUndo()
            });
        }
        
        async function handleFileSelect(event) {
            const files = event.target.files;
            if (files.length === 0) return;

            const allowedExtensions = /\.(m3u|m3u8|pls|json|csv)$/i;
            const validFiles = Array.from(files).filter(file => allowedExtensions.test(file.name));
            
            if (validFiles.length === 0) {
                return showToast("Please choose a file with a valid extension (M3U, PLS, JSON, CSV)", "error");
            }
            
            document.getElementById('loadingIndicator').style.display = 'block';
            
            try {
                const parsePromises = validFiles.map(file => 
                    file.text().then(content => parseFileContent(content, file.name))
                );
                
                const allNewChannels = (await Promise.all(parsePromises)).flat();

                if (allNewChannels.length > 0) {
                    channelsData = [];
                    const numChannels = allNewChannels.length;
                    const numFiles = validFiles.length;
                    
                    const channelsPart = generateCountString(numChannels, {singular: 'channel', plural: 'channels'});
                    const filesPart = generateCountString(numFiles, {singular: 'file', plural: 'files'});

                    processNewChannels(allNewChannels, `Imported ${channelsPart} from ${filesPart}.`);
                    showPlaylistControls();
                } else {
                    showToast("The selected files do not contain any valid channels.", "error");
                }
            } catch (error) {
                console.error("Error reading files:", error);
                showToast("An error occurred while reading the files.", "error");
            } finally {
                document.getElementById('loadingIndicator').style.display = 'none';
                event.target.value = '';
            }
        }

        function displayPaginatedChannels() { const totalPages = Math.ceil(displayedChannels.length / rowsPerPage); currentPage = Math.max(1, Math.min(currentPage, totalPages)); const startIndex = (currentPage - 1) * rowsPerPage; const endIndex = startIndex + rowsPerPage; const pagedChannels = displayedChannels.slice(startIndex, endIndex); renderTable(pagedChannels, startIndex); setupPaginationControls(totalPages); updateBulkActionsUI(); }
        
        function renderTable(channels, startIndex) { 
            const resultsDiv = document.getElementById('results'); 
            resultsDiv.innerHTML = ''; 
            if (channelsData.length === 0) { 
                resultsDiv.innerHTML = '<p>The list is empty. Add a channel or upload a file.</p>'; 
                return; 
            } 
            if (channels.length === 0) { 
                resultsDiv.innerHTML = '<p>No results match the search criteria.</p>'; 
                return; 
            } 
            const table = document.createElement('table'); 
            const tbody = document.createElement('tbody'); 
            
            table.innerHTML = `<thead><tr><th>No.</th><th>Channel Name</th><th>Group</th></tr></thead>`; 

            channels.forEach((channel, index) => { 
                const originalIndex = channelsData.indexOf(channel); 
                const row = tbody.insertRow(); 

                row.setAttribute('draggable', 'true');
                
                row.dataset.index = originalIndex; 
                if (selectedIndices.has(originalIndex)) { 
                    row.classList.add('selected'); 
                } 
                
                const groupsDisplay = channel.groups && channel.groups.length > 0 ? channel.groups.join(', ') : 'Unclasfd'; 
                
                const logoHtml = `
                    ${channel.logo ? `<img src="${channel.logo}" alt="Logo" onclick="event.stopPropagation(); openEditModal(${originalIndex});" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">` : ''}
                    <span class="placeholder" style="${channel.logo ? 'display:none;' : ''}" onclick="event.stopPropagation(); openEditModal(${originalIndex});">📺</span>
                `;
                
                const statusDotDisplay = (channel.status && channel.status !== 'unchecked') ? 'inline-block' : 'none';

                row.innerHTML = `
                    <td>
                        <div class="channel-index-cell">
                             <span class="status-dot ${channel.status || 'unchecked'}" data-index="${originalIndex}" style="display: ${statusDotDisplay};"></span>
                             <span>${startIndex + index + 1}</span>
                             <button class="action-button-icon play-btn-icon" onclick="triggerPlay(event, ${originalIndex})" title="Play Channel">▶</button>
                        </div>
                    </td>
                    <td class="channel-name">
                        ${logoHtml}
                        <span class="name-text">${channel.name || ''}</span>
                    </td>
                    <td class="channel-group">${groupsDisplay}</td>
                `;
                
                row.addEventListener('click', handleRowClick);
                row.addEventListener('dragstart', handleDragStart);
                row.addEventListener('dragend', handleDragEnd);
                row.addEventListener('dragenter', handleDragEnter);
                row.addEventListener('dragleave', handleDragLeave);
                row.addEventListener('dragover', handleDragOver);
                row.addEventListener('drop', handleDrop);
            }); 
            table.appendChild(tbody); 
            resultsDiv.appendChild(table); 
        }
        
        function togglePlayMode() {
            isPlayMode = !isPlayMode;
            document.body.classList.toggle('play-mode-enabled', isPlayMode);
            const toggleButton = document.getElementById('modalPlayModeToggle');
            if (toggleButton) {
                toggleButton.textContent = isPlayMode ? 'Disable Play Mode' : 'Enable Play Mode';
            }
        }

        function triggerPlay(event, index) {
            event.stopPropagation();
            const channel = channelsData[index];
            if (!channel || !channel.url) {
                return showToast("This channel has no stream URL.", "error");
            }
            playChannel(channel.url);
        }

        function playChannel(url) {
            stopPlayer(true);
            
            const playerContainer = document.getElementById('player-container');
            const popup = document.getElementById('video-popup');
            
            const video = document.createElement('video');
            video.id = 'player';
            video.playsinline = true;
            video.controls = true;
            playerContainer.appendChild(video);
            popup.classList.add('active');
            
            if (url.endsWith('.m3u8') && Hls.isSupported()) {
                hls = new Hls({ autoLevelEnabled: false });
                hls.loadSource(url);
                hls.attachMedia(video);
                hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
                    const plyrOptions = {
                        i18n: {
                            qualityLabel: {
                                ...[...data.levels].reduce((labels, level) => {
                                    const bitrate = level.bitrate;
                                    labels[bitrate] = `${(bitrate / 1000000).toFixed(1)} Mbps`;
                                    return labels;
                                }, {})
                            }
                        }
                    };
                    if (data.levels.length > 1) {
                        plyrOptions.quality = {
                            default: data.levels[0].bitrate,
                            options: [...data.levels].reverse().map(level => level.bitrate),
                            forced: true,
                            onChange: (selectedBitrate) => {
                                hls.levels.forEach((level, levelIndex) => {
                                    if (level.bitrate === selectedBitrate) {
                                        hls.currentLevel = levelIndex;
                                    }
                                });
                            },
                        };
                    }
                    player = new Plyr(video, plyrOptions);
                    player.play();
                });
            } else {
                video.src = url;
                player = new Plyr(video, {});
                player.play();
            }
        }

        function stopPlayer(isSwitchingChannel = false) {
            const playerContainer = document.getElementById('player-container');
            const popup = document.getElementById('video-popup');
            const popupContent = document.getElementById('popup-content');

            if (player) { player.destroy(); player = null; }
            if (hls) { hls.destroy(); hls = null; }
            
            playerContainer.innerHTML = '';
            popupContent.style.transform = 'translateY(0)';
            
            const dragEndEvent = new Event('mouseup');
            document.dispatchEvent(dragEndEvent);

            if (!isSwitchingChannel) {
                popup.classList.remove('active');
            }
        }

        function setupPaginationControls(totalPages) { const container = document.getElementById('paginationControls'); container.innerHTML = ''; if (totalPages <= 1) return; container.innerHTML = `<button id="prevPage" onclick="changePage(-1)" ${currentPage === 1 ? 'disabled' : ''}>Previous</button><span id="pageInfo">Page ${currentPage} of ${totalPages}</span><button id="nextPage" onclick="changePage(1)" ${currentPage === totalPages ? 'disabled' : ''}>Next</button>`; }
        function changePage(direction) { currentPage += direction; displayPaginatedChannels(); }
        
        function populateGroupFilter(targetSelectId = 'groupFilter') {
            const groupFilter = document.getElementById(targetSelectId);
            const savedValue = groupFilter.value;
            groupFilter.innerHTML = '<option value="all">All Groups</option>';
            const allGroups = channelsData.flatMap(ch => (ch.groups && ch.groups.length) ? ch.groups : []);
            const hasUncategorized = channelsData.some(ch => !ch.groups || ch.groups.length === 0);
            const uniqueGroups = [...new Set(allGroups)];
            uniqueGroups.sort((a, b) => a.localeCompare(b)).forEach(group => {
                const option = document.createElement('option');
                option.value = group;
                option.textContent = group;
                groupFilter.appendChild(option);
            });
            if (hasUncategorized) {
                const option = document.createElement('option');
                option.value = 'uncategorized';
                option.textContent = 'Uncategorized';
                groupFilter.appendChild(option);
            }
            if (Array.from(groupFilter.options).some(opt => opt.value === savedValue)) {
                groupFilter.value = savedValue;
            }
        }

        function parseM3uPlaylist(content) { const lines = content.split('\n'); const channels = []; let currentInfo = ''; for (const line of lines) { const trimmedLine = line.trim(); if (trimmedLine.startsWith('#EXTINF')) { currentInfo = trimmedLine; } else if (currentInfo && !trimmedLine.startsWith('#') && trimmedLine.length > 0) { const name = currentInfo.match(/,([^,]*)$/)?.[1].trim() || 'Unknown Channel'; const logo = currentInfo.match(/tvg-logo="([^"]*)"/i)?.[1] || ''; const chno = parseInt(currentInfo.match(/tvg-chno="([^"]*)"/i)?.[1]) || 0; const groupString = currentInfo.match(/group-title="([^"]*)"/i)?.[1] || ''; const groups = groupString ? groupString.split(';').map(g => g.trim()).filter(g => g) : []; channels.push({ name, groups, logo, chno, url: trimmedLine, originalExtinf: currentInfo, status: 'unchecked' }); currentInfo = ''; } } return channels; }
        
        function parsePlsPlaylist(content) {
            const lines = content.split('\n');
            const channels = [];
            const channelsMap = {};
            const regex = /^(File|Title)(\d+)=(.+)$/i;

            lines.forEach(line => {
                const match = line.match(regex);
                if (match) {
                    const key = match[1].toLowerCase();
                    const index = match[2];
                    const value = match[3].trim();
                    if (!channelsMap[index]) {
                        channelsMap[index] = {};
                    }
                    channelsMap[index][key] = value;
                }
            });

            for (const index in channelsMap) {
                const entry = channelsMap[index];
                if (entry.file && entry.title) {
                    channels.push({
                        name: entry.title,
                        url: entry.file,
                        groups: [],
                        logo: '',
                        chno: 0,
                        originalExtinf: '',
                        status: 'unchecked'
                    });
                }
            }
            return channels;
        }

        function parseJsonPlaylist(content) {
            try {
                const data = JSON.parse(content);
                if (!Array.isArray(data)) {
                    showToast("Invalid JSON file: Must contain an array of channels.", "error");
                    return [];
                }
                return data.map(item => ({
                    name: item.name || 'Unknown Channel',
                    url: item.url || '',
                    logo: item.logo || '',
                    groups: Array.isArray(item.groups) ? item.groups : [],
                    chno: item.chno || 0,
                    originalExtinf: item.originalExtinf || '',
                    status: 'unchecked'
                })).filter(ch => ch.url);
            } catch (e) {
                showToast("Error parsing JSON file.", "error");
                return [];
            }
        }

        function parseCsvPlaylist(content) {
            try {
                const lines = content.split(/\r?\n/).filter(line => line.trim() !== '');
                if (lines.length < 2) return [];

                const header = lines[0].split(',').map(h => h.trim().toLowerCase());
                const nameIndex = header.indexOf('name');
                const urlIndex = header.indexOf('url');
                const logoIndex = header.indexOf('logo');
                const groupsIndex = header.indexOf('groups');

                if (nameIndex === -1 || urlIndex === -1) {
                    showToast("Invalid CSV file: Must contain at least 'name' and 'url' columns.", "error");
                    return [];
                }

                const channels = [];
                for (let i = 1; i < lines.length; i++) {
                    const data = lines[i].split(','); 
                    const name = data[nameIndex] || 'Unknown Channel';
                    const url = data[urlIndex] || '';
                    if (!url) continue;

                    const logo = logoIndex > -1 ? data[logoIndex] : '';
                    const groupsString = groupsIndex > -1 ? data[groupsIndex] : '';
                    const groups = groupsString ? groupsString.split(';').map(g => g.trim()) : [];

                    channels.push({ name, url, logo, groups, status: 'unchecked' });
                }
                return channels;
            } catch (e) {
                showToast("Error parsing CSV file.", "error");
                return [];
            }
        }
        
        function parseFileContent(content, fileName) {
            const extension = fileName.split('.').pop().toLowerCase();
            if (content.trim().toLowerCase().startsWith('[playlist]') || extension === 'pls') {
                return parsePlsPlaylist(content);
            } else if (extension === 'm3u' || extension === 'm3u8') {
                return parseM3uPlaylist(content);
            } else if (extension === 'json') {
                return parseJsonPlaylist(content);
            } else if (extension === 'csv') {
                return parseCsvPlaylist(content);
            }
            if (content.trim().startsWith('#EXTM3U')) {
                return parseM3uPlaylist(content);
            }
            return [];
        }


        function processNewChannels(newChannels, successMessage) {
            const isInitialLoad = channelsData.length === 0;
            const preMergeLength = channelsData.length;
            channelsData.push(...newChannels);

            let duplicatesFound = 0;
            if (!isInitialLoad || newChannels.length > preMergeLength) {
                const seen = new Set();
                let uniqueCount = 0;
                const tempChannels = isInitialLoad ? newChannels : channelsData;
                tempChannels.forEach(channel => {
                    const key = `${(channel.name || '').trim()}-${(channel.url || '').trim()}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        uniqueCount++;
                    }
                });
                duplicatesFound = tempChannels.length - seen.size;
            }
            
            showToast(successMessage, 'success');

            if (duplicatesFound > 0) {
                const action = {
                    text: 'Remove now',
                    callback: () => {
                        findDuplicates('name-url', true); 
                    }
                };
                const countStr = generateCountString(duplicatesFound, {singular: 'duplicate channel', plural: 'duplicate channels'});
                showToast(`Found ${countStr}.`, 'info', 8000, action);
            }

            isMerged = !isInitialLoad;
            isSorted = false;
            isCheckPerformed = false; 
            updateChannelCheckMenu(); 
            updateAndRefreshUI();
        }
        
        async function mergePlaylists(event) { 
            const files = event.target.files; 
            if (!files.length) return; 
            closeModal('mergeModal'); 
            document.getElementById('loadingIndicator').style.display = 'block'; 

            const parsePromises = Array.from(files).map(file => 
                file.text().then(content => parseFileContent(content, file.name))
            );
            const newChannels = (await Promise.all(parsePromises)).flat();
            
            if(newChannels.length > 0) { 
                const countStr = generateCountString(newChannels.length, {singular: 'new channel', plural: 'new channels'});
                processNewChannels(newChannels, `Merged ${countStr}.`); 
            } else { 
                showToast("No channels found in the selected files.", "info"); 
            } 
            document.getElementById('loadingIndicator').style.display = 'none'; 
            event.target.value = ''; 
        }

        function removeDuplicates(criteria = 'name-url') { const originalLength = channelsData.length; const seen = new Set(); channelsData = channelsData.filter(channel => { let key; const name = (channel.name || '').trim(); const url = (channel.url || '').trim(); const groupKey = (channel.groups || []).join(';'); if (criteria === 'name-url') key = `${name}-${url}`; else if (criteria === 'name') key = name; else if (criteria === 'name-url-group') key = `${name}-${url}-${groupKey}`; if (key && !seen.has(key)) { seen.add(key); return true; } return false; }); return originalLength - channelsData.length; }
        function removeDuplicatesManually() { if (channelsData.length === 0) return showToast("No channels available.", 'error'); openModal('removeDuplicatesModal'); }
        
        function showDuplicateCriteriaStep() {
            document.getElementById('removeDuplicatesModal').classList.add('modal-small-top');
            document.getElementById('duplicate-criteria-step').style.display = 'block';
            document.getElementById('duplicate-results-step').style.display = 'none';
        }

        function findDuplicates(criteria, openFromToast = false) {
            if (!criteria) {
                criteria = document.querySelector('input[name="duplicateCriteria"]:checked').value;
            }
            
            const duplicatesMap = new Map();

            if (criteria === 'partial-name-url') {
                // New logic for partial search
                const urlMap = new Map();
                channelsData.forEach((channel, index) => {
                    if (!urlMap.has(channel.url)) {
                        urlMap.set(channel.url, []);
                    }
                    urlMap.get(channel.url).push({ channel, index });
                });

                for (const group of urlMap.values()) {
                    if (group.length < 2) continue;

                    const matchedInGroup = new Set();
                    for (let i = 0; i < group.length; i++) {
                        for (let j = i + 1; j < group.length; j++) {
                            const item1 = group[i];
                            const item2 = group[j];
                            
                            const name1 = item1.channel.name.toLowerCase();
                            const name2 = item2.channel.name.toLowerCase();

                            // Check if one name contains the other
                            if (name1.includes(name2) || name2.includes(name1)) {
                                matchedInGroup.add(item1);
                                matchedInGroup.add(item2);
                            }
                        }
                    }
                    if (matchedInGroup.size > 0) {
                        const key = `partial-${group[0].channel.url}-${[...matchedInGroup].map(i=>i.index).join('-')}`;
                        duplicatesMap.set(key, [...matchedInGroup]);
                    }
                }

            } else {
                // Old logic for exact match search
                channelsData.forEach((channel, index) => {
                    let key;
                    const name = (channel.name || '').trim();
                    const url = (channel.url || '').trim();
                    const groupKey = (channel.groups || []).join(';');
                    if (criteria === 'name-url') key = `${name}-${url}`;
                    else if (criteria === 'name') key = name;
                    else if (criteria === 'name-url-group') key = `${name}-${url}-${groupKey}`;

                    if (key && !duplicatesMap.has(key)) {
                        duplicatesMap.set(key, []);
                    }
                    if(key) duplicatesMap.get(key).push({ channel, index });
                });
            }


            const duplicateGroups = Array.from(duplicatesMap.values()).filter(group => group.length > 1);
            
            if (duplicateGroups.length === 0) {
                showToast("No duplicate channels found based on this criteria.", "info");
                if (!openFromToast) closeModal('removeDuplicatesModal');
                return;
            }
            
            if(openFromToast) openModal('removeDuplicatesModal');
            
            document.getElementById('removeDuplicatesModal').classList.remove('modal-small-top');

            const resultsList = document.getElementById('duplicate-results-list');
            resultsList.innerHTML = '';
            duplicateGroups.forEach((group, groupIndex) => {
                group.sort((a, b) => a.channel.name.length - b.channel.name.length);

                const groupDiv = document.createElement('div');
                groupDiv.className = 'duplicate-group';
                
                const groupTitle = document.createElement('h4');
                groupTitle.textContent = `${group[0].channel.name}`;
                groupDiv.appendChild(groupTitle);

                group.forEach((item, itemIndex) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'duplicate-channel-item';
                    
                    const radio = document.createElement('input');
                    radio.type = 'radio';
                    radio.name = `dup-group-${groupIndex}`;
                    radio.value = item.index;
                    radio.id = `dup-radio-${groupIndex}-${itemIndex}`;
                    if (itemIndex === 0) { 
                        radio.checked = true;
                    }

                    const label = document.createElement('label');
                    label.htmlFor = `dup-radio-${groupIndex}-${itemIndex}`;
                    
                    let logoHTML;
                    if (item.channel.logo) {
                        logoHTML = `<img src="${item.channel.logo}" class="dup-logo" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-block';"><span class="dup-logo-placeholder" style="display:none;">📺</span>`;
                    } else {
                        logoHTML = '<span class="dup-logo-placeholder">📺</span>';
                    }
                    
                    const infoIcon = `<span class="dup-info-icon" onclick="showDuplicateInfo(${item.index})">ⓘ</span>`;

                    label.innerHTML = `${logoHTML} ${item.channel.name}`;
                    
                    itemDiv.appendChild(radio);
                    itemDiv.appendChild(label);
                    itemDiv.appendChild(document.createRange().createContextualFragment(infoIcon));
                    groupDiv.appendChild(itemDiv);
                });
                resultsList.appendChild(groupDiv);
            });
            
            document.getElementById('duplicate-criteria-step').style.display = 'none';
            document.getElementById('duplicate-results-step').style.display = 'flex';
        }
        
        function showDuplicateInfo(index) {
            document.getElementById('removeDuplicatesModal').style.zIndex = '999';
            openEditModal(index, true);
            document.getElementById('editModal').style.zIndex = '2001';
        }

        function executeDuplicateDeletion() {
            const radioGroups = document.querySelectorAll('#duplicate-results-list .duplicate-group');
            const indicesToKeep = new Set();
            radioGroups.forEach(group => {
                const selectedRadio = group.querySelector('input[type="radio"]:checked');
                if (selectedRadio) {
                    indicesToKeep.add(parseInt(selectedRadio.value));
                }
            });

            const indicesToRemove = new Set();
            radioGroups.forEach(group => {
                const allRadios = group.querySelectorAll('input[type="radio"]');
                allRadios.forEach(radio => {
                    const index = parseInt(radio.value);
                    if (!indicesToKeep.has(index)) {
                        indicesToRemove.add(index);
                    }
                });
            });

            if (indicesToRemove.size === 0) {
                return showToast("No channels were selected for deletion.", "info");
            }
            
            undoManager.registerUndo();

            const sortedIndicesToRemove = Array.from(indicesToRemove).sort((a,b) => b-a);
            sortedIndicesToRemove.forEach(index => {
                channelsData.splice(index, 1);
            });
            
            updateAndRefreshUI();
            setTimeout(() => closeModal('removeDuplicatesModal'), 0);
            
            const countStr = generateCountString(sortedIndicesToRemove.length, {singular: 'duplicate channel', plural: 'duplicate channels'});
            showToast(`Deleted ${countStr}.`, 'success', 8000, {
                text: 'Undo',
                callback: () => undoManager.performUndo()
            });
        }

        async function fetchAndParseUrls(urls) {
            let allNewChannels = [];
            let failedCount = 0;
            for (const url of urls) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Failed to load URL (Status: ${response.status})`);
                    const content = await response.text();
                    const channelsFromUrl = parseFileContent(content, url);
                    allNewChannels.push(...channelsFromUrl);
                } catch (error) {
                    failedCount++;
                    console.error(`Error loading URL ${url}:`, error);
                }
            }
            return { channels: allNewChannels, failedCount: failedCount };
        }

        async function processMultiUrlLoad() { 
            const urlsText = document.getElementById('multiUrlTextarea').value; 
            const urls = urlsText.split('\n').map(u => u.trim()).filter(u => u); 
            if (urls.length === 0) { return showToast("Please enter at least one URL", "error"); } 
            closeModal('multiUrlModal'); 
            document.getElementById('loadingIndicator').style.display = 'block'; 

            const { channels: allNewChannels } = await fetchAndParseUrls(urls);
            
            document.getElementById('loadingIndicator').style.display = 'none'; 
            if (allNewChannels.length > 0) { 
                channelsData = []; 
                const countStr = generateCountString(allNewChannels.length, {singular: 'channel', plural: 'channels'});
                processNewChannels(allNewChannels, `Successfully loaded ${countStr}.`); 
                showPlaylistControls(); 
            } else { 
                showToast("Failed to load any channels from the provided URLs", "error"); 
            } 
        }
        
        function createNewPlaylist() {
            if (channelsData.length > 0) {
                undoManager.registerUndo();
            }
            channelsData = [];
            displayedChannels = [];
            selectedIndices.clear();
            localStorage.removeItem('m3uEditorSession');
            
            isCheckPerformed = false;
            updateChannelCheckMenu();

            showPlaylistControls();
            updateAndRefreshUI();

            showToast('Created a new empty playlist.', 'success', 8000, {
                text: 'Undo',
                callback: () => undoManager.performUndo()
            });
        }
        
        function resetToInitialView() {
            document.getElementById('uploadArea').style.display = 'block';
            document.getElementById('urlLoadContainer').style.display = 'block';
            document.getElementById('toolsMergeRow').style.display = 'none';
            document.getElementById('results').innerHTML = '';
            document.getElementById('paginationControls').innerHTML = '';
            
            const filterButton = document.getElementById('openSearchFilterModalButton');
            if (filterButton) {
                filterButton.textContent = 'Search & Filter';
            }
            isFilterActiveForButton = false;
        }

        function startNewSession() {
            channelsData = [];
            displayedChannels = [];
            selectedIndices.clear();
            localStorage.removeItem('m3uEditorSession');

            isCheckPerformed = false;
            updateChannelCheckMenu();

            resetToInitialView();
            
            closeModal('advancedOptionsModal');
        }

        function executeSort() {
            const criteria = document.querySelector('input[name="sortCriteria"]:checked').value;
            const isDescending = document.getElementById('sort-descending').checked;
            const isGroupingEnabled = document.getElementById('sort-grouping').checked;

            if (criteria === 'moveBlock') {
                const target = parseInt(document.getElementById('moveTargetIndex').value);
                if (isNaN(target)) { return showToast('Please enter the target position', 'error'); }
                const maxIndex = channelsData.length;
                if (target < 1 || target > maxIndex + 1) { return showToast(`Target position is outside the list range (1 - ${maxIndex})`, 'error'); }

                if (selectedIndices.size > 0) {
                    const sortedIndices = Array.from(selectedIndices).sort((a, b) => b - a);
                    const blockToMove = [];
                    sortedIndices.forEach(index => {
                        blockToMove.unshift(channelsData.splice(index, 1)[0]);
                    });
                    
                    channelsData.splice(target - 1, 0, ...blockToMove);
                    selectedIndices.clear();
                } else {
                    const from = parseInt(document.getElementById('moveFromIndex').value);
                    const to = parseInt(document.getElementById('moveToIndex').value);
                    if (isNaN(from) || isNaN(to)) { return showToast('Please fill in both "from" and "to" fields', 'error'); }
                    if (from > to) { return showToast('The "from" number must be less than or equal to the "to" number', 'error'); }
                    if (from < 1 || to > maxIndex) { return showToast(`The entered numbers are outside the list range (1 - ${maxIndex})`, 'error'); }

                    const fromIndex = from - 1;
                    const toIndex = to - 1;
                    const count = toIndex - fromIndex + 1;
                    const blockToMove = channelsData.splice(fromIndex, count);
                    channelsData.splice(target - 1, 0, ...blockToMove);
                }
            } else {
                const scope = document.getElementById('sort-scope-selector').value;
                const sortFunction = (a, b) => (a.name || '').localeCompare(b.name || '');
                
                let channelsToSort;
                let originalIndices;

                if (scope === 'filtered') {
                    channelsToSort = [...displayedChannels];
                    originalIndices = displayedChannels.map(ch => channelsData.indexOf(ch)).sort((a, b) => a - b);
                } else if (scope === 'selected') {
                    originalIndices = Array.from(selectedIndices).sort((a,b) => a - b);
                    channelsToSort = originalIndices.map(index => channelsData[index]);
                } else {
                    channelsToSort = [...channelsData];
                    originalIndices = channelsData.map((_, i) => i);
                }
                
                if (channelsToSort.length === 0) {
                    closeModal('sortModal');
                    return;
                }

                if (criteria === 'alphabetical') {
                    channelsToSort.sort(sortFunction);
                } else if (criteria === 'name') {
                    const term = document.getElementById('sortByNameField').value.toLowerCase().trim();
                    if (term) channelsToSort.sort((a, b) => (b.name.toLowerCase().includes(term) - a.name.toLowerCase().includes(term)) || sortFunction(a, b));
                    else channelsToSort.sort(sortFunction);
                } else if (criteria === 'group') {
                    const term = document.getElementById('sortByGroupField').value.toLowerCase().trim();
                    if (term) channelsToSort.sort((a, b) => {
                        const aHasGroup = a.groups && a.groups.some(g => g.toLowerCase().includes(term));
                        const bHasGroup = b.groups && b.groups.some(g => g.toLowerCase().includes(term));
                        return (bHasGroup - aHasGroup) || sortFunction(a, b);
                    });
                    else channelsToSort.sort(sortFunction);
                }
                
                if (isDescending) {
                    channelsToSort.reverse();
                }

                if (scope === 'all' || !isGroupingEnabled) {
                     originalIndices.forEach((originalIndex, i) => {
                        channelsData[originalIndex] = channelsToSort[i];
                    });
                } else {
                    const insertionIndex = originalIndices[0];
                    const indicesToRemove = originalIndices.sort((a, b) => b - a);
                    
                    indicesToRemove.forEach(index => {
                        channelsData.splice(index, 1);
                    });

                    channelsData.splice(insertionIndex, 0, ...channelsToSort);
                    selectedIndices.clear();
                }
            }

            isSorted = true;
            isMerged = false;
            updateAndRefreshUI();
            setTimeout(() => closeModal('sortModal'), 0);
        }

        function executeGroupAction() {
            const action = document.querySelector('input[name="groupAction"]:checked').value;
            const selectedTarget = document.getElementById('groupSelector').value;
            const isFilteredResultTarget = selectedTarget === '__filtered__';
            const isSelectedResultTarget = selectedTarget === '__selected__';

            if (action === 'removeAll') {
                undoManager.registerUndo();
                channelsData.forEach(channel => { channel.groups = []; });
                updateAndRefreshUI();
                showToast('Removed all groups.', 'success', 8000, {
                    text: 'Undo',
                    callback: () => undoManager.performUndo()
                });
                return;
            }

            const getTargetChannels = () => {
                if (isFilteredResultTarget) return [...displayedChannels];
                if (isSelectedResultTarget) return Array.from(selectedIndices).map(index => channelsData[index]);
                const isUncategorized = selectedTarget === 'Uncategorized';
                return channelsData.filter(channel => {
                    if (isUncategorized) return !channel.groups || channel.groups.length === 0;
                    return channel.groups && channel.groups.includes(selectedTarget);
                });
            };

            const targetChannels = getTargetChannels();
            if (targetChannels.length === 0 && !(isFilteredResultTarget || isSelectedResultTarget)) {
                showToast('No channels found in the selected group', 'info');
                return;
            }

            if (action === 'delete') {
                undoManager.registerUndo();
                const originalCount = channelsData.length;
                const targetIndices = new Set(targetChannels.map(ch => channelsData.indexOf(ch)));
                channelsData = channelsData.filter((_, index) => !targetIndices.has(index));
                const removedCount = originalCount - channelsData.length;
                const removedStr = generateCountString(removedCount, {singular: 'channel', plural: 'channels'});
                updateAndRefreshUI();
                showToast(`Deleted ${removedStr}.`, 'success', 8000, {
                    text: 'Undo',
                    callback: () => undoManager.performUndo()
                });
            } else if (action === 'rename') {
                const newGroupNameString = document.getElementById('newGroupNameField').value.trim();
                const isAdditive = document.getElementById('rename-add-as-new').checked;
                const targetIndices = new Set(targetChannels.map(ch => channelsData.indexOf(ch)));
                const isUncategorized = selectedTarget === 'Uncategorized';
                
                if (newGroupNameString === '' && !isAdditive) {
                    channelsData.forEach((channel, index) => {
                        if (targetIndices.has(index)) {
                            if (isFilteredResultTarget || isSelectedResultTarget || isUncategorized) {
                                channel.groups = [];
                            } else {
                                channel.groups = channel.groups.filter(g => g !== selectedTarget);
                            }
                        }
                    });
                } else {
                    const newGroups = newGroupNameString.split(';').map(g => g.trim()).filter(g => g);
                    if (newGroups.length === 0 && !isAdditive) return;
                    
                    channelsData.forEach((channel, index) => {
                        if (targetIndices.has(index)) {
                            let currentGroups = new Set(channel.groups || []);
                            if (!isAdditive) {
                                if (isFilteredResultTarget || isSelectedResultTarget || isUncategorized) {
                                    currentGroups.clear();
                                } else {
                                    currentGroups.delete(selectedTarget);
                                }
                            }
                            newGroups.forEach(g => currentGroups.add(g));
                            channel.groups = Array.from(currentGroups);
                        }
                    });
                }
                updateAndRefreshUI();
            } else if (action === 'merge') {
                const mergeTargetGroup = document.getElementById('mergeTargetSelector').value;
                if (!mergeTargetGroup || selectedTarget === mergeTargetGroup) {
                    return showToast('Please select a different group to merge with.', 'error');
                }
                showConfirm('Merge Groups', `Are you sure you want to merge all channels from "${selectedTarget}" into the "${mergeTargetGroup}" group?`, () => {
                    const targetIndices = new Set(targetChannels.map(ch => channelsData.indexOf(ch)));
                    channelsData.forEach((channel, index) => {
                        if (targetIndices.has(index)) {
                            const currentGroups = new Set(channel.groups || []);
                            currentGroups.delete(selectedTarget);
                            currentGroups.add(mergeTargetGroup);
                            channel.groups = Array.from(currentGroups);
                        }
                    });
                    updateAndRefreshUI();
                });
            } else if (action === 'exportGroup') {
                if (targetChannels.length > 0) {
                    const content = createPlaylistContent('m3u', targetChannels);
                    let fileName = 'playlist.m3u';
                    const countStr = generateCountString(targetChannels.length, {singular: 'channel', plural: 'channels'});
                    if (isFilteredResultTarget) fileName = `Search Results (${countStr}).m3u`;
                    else if (isSelectedResultTarget) fileName = `Selected Channels (${countStr}).m3u`;
                    else fileName = `Group_${selectedTarget.replace(/[\/\\?%*:|"<>]/g, '-')}.m3u`;
                    
                    if(content) downloadFile(content, fileName, 'text/plain;charset=utf-8');
                } else {
                    showToast('No channels to export.', 'info');
                }
                closeModal('manageGroupsModal');
            }

             if (action !== 'exportGroup') {
                setTimeout(() => closeModal('manageGroupsModal'), 0);
            }
        }

        function updateAndRefreshUI() {
            updateTvgChnoInAllChannels();
            searchChannels();
            saveSession();
        }

        async function executeMerge() {
            const urlsText = document.getElementById('mergeUrlTextarea').value;
            const urls = urlsText.split('\n').map(u => u.trim()).filter(u => u);
            if (urls.length === 0) {
                return showToast("Please enter at least one URL to merge", "error");
            }
            closeModal('mergeModal');
            document.getElementById('loadingIndicator').style.display = 'block';

            const { channels: allNewChannels, failedCount } = await fetchAndParseUrls(urls);

            document.getElementById('loadingIndicator').style.display = 'none';

            if (allNewChannels.length > 0) {
                const channelStr = generateCountString(allNewChannels.length, {singular: 'channel', plural: 'channels'});
                const urlStr = generateCountString(urls.length - failedCount, {singular: 'URL', plural: 'URLs'});
                processNewChannels(allNewChannels, `Merged ${channelStr} from ${urlStr}.`);
            } else {
                const urlStr = generateCountString(urls.length, {singular: 'URL', plural: 'URLs'});
                showToast(`Failed to load any channels from the ${urlStr}.`, "error");
            }
        }
        
        function saveEdit() { 
            const originalIndex = parseInt(document.getElementById('editOriginalIndex').value); 
            let newIndex = parseInt(document.getElementById('editIndexField').value) - 1; 
            if (!document.getElementById('editName').value || !document.getElementById('editUrl').value) return showToast("Name and URL are required", "error"); 
            const groups = document.getElementById('editGroup').value.split(';').map(g => g.trim()).filter(g => g); 
            const channel = { name: document.getElementById('editName').value, groups: groups, logo: document.getElementById('editLogo').value, url: document.getElementById('editUrl').value, originalExtinf: channelsData[originalIndex].originalExtinf, status: channelsData[originalIndex].status }; 
            if (newIndex !== originalIndex && newIndex < channelsData.length) { 
                channelsData.splice(originalIndex, 1); 
                channelsData.splice(newIndex, 0, channel); 
            } else { 
                channelsData[originalIndex] = channel; 
            } 
            updateAndRefreshUI(); 
            setTimeout(() => closeModal('editModal'), 0); 
            populateGroupFilter(); 
        }

        function saveNewChannel() { 
            if (!document.getElementById('addName').value || !document.getElementById('addUrl').value) return showToast("Name and URL are required", 'error'); 
            let newIndex = parseInt(document.getElementById('addIndexField').value) - 1; 
            const groups = document.getElementById('addGroup').value.split(';').map(g => g.trim()).filter(g => g); 
            const newChannel = { name: document.getElementById('addName').value, groups: groups, logo: document.getElementById('addLogo').value, url: document.getElementById('addUrl').value, status: 'unchecked' }; 
            if (newIndex >= 0 && newIndex <= channelsData.length) { 
                channelsData.splice(newIndex, 0, newChannel); 
            } else { 
                channelsData.push(newChannel); 
            } 
            updateAndRefreshUI(); 
            setTimeout(() => closeModal('addModal'), 0); 
            populateGroupFilter(); 
        }

        function openAddModal() { document.getElementById('addIndexField').value = channelsData.length + 1; ['addName', 'addGroup', 'addLogo', 'addUrl'].forEach(id => document.getElementById(id).value = ''); updateLogoPreview('addPreviewImage', ''); openModal('addModal'); }
        
        function openEditModal(index, readOnly = false) {
            const modal = document.getElementById('editModal');
            const channel = channelsData[index];
            if (!channel) return;
            
            document.getElementById('editIndexField').value = index + 1;
            document.getElementById('editName').value = channel.name || '';
            document.getElementById('editGroup').value = (channel.groups || []).join(';');
            document.getElementById('editLogo').value = channel.logo || '';
            document.getElementById('editUrl').value = channel.url || '';
            document.getElementById('editOriginalIndex').value = index;
            updateLogoPreview('previewImage', channel.logo);
            
            const fields = ['editIndexField', 'editName', 'editGroup', 'editLogo', 'editUrl'];
            fields.forEach(id => {
                document.getElementById(id).readOnly = readOnly;
            });
            
            document.querySelector('#editModal .modal-buttons button[onclick="saveEdit()"]').style.display = readOnly ? 'none' : 'inline-block';
            const cancelButton = document.querySelector('#editModal .modal-buttons button.cancel');
            cancelButton.textContent = readOnly ? 'Close' : 'Cancel';
            
            if (readOnly) {
                modal.style.zIndex = '2001';
            }
            openModal('editModal');
        }

        function populateDynamicScopeSelector(selectorId, baseText = {}) {
            const defaultText = { filtered: 'Search & Filter Results', selected: 'Selected Channels', all: 'All Channels' };
            const text = { ...defaultText, ...baseText };
            
            const scopeSelector = document.getElementById(selectorId);
            scopeSelector.innerHTML = '';
            const isFiltered = displayedChannels.length < channelsData.length;
            const hasSelection = selectedIndices.size > 0;
            const channelWords = {singular: 'channel', plural: 'channels'};

            if (isFiltered) {
                const countStr = generateCountString(displayedChannels.length, channelWords);
                scopeSelector.add(new Option(`${text.filtered} (${countStr})`, 'filtered'));
            }
            if (hasSelection) {
                const countStr = generateCountString(selectedIndices.size, channelWords);
                scopeSelector.add(new Option(`${text.selected} (${countStr})`, 'selected'));
            }
            const allCountStr = generateCountString(channelsData.length, channelWords);
            scopeSelector.add(new Option(`${text.all} (${allCountStr})`, 'all'));

            if (isFiltered) {
                scopeSelector.value = 'filtered';
            } else if (hasSelection) {
                scopeSelector.value = 'selected';
            } else {
                scopeSelector.value = 'all';
            }
        }
        
        function openSortModal() {
            if (channelsData.length === 0) return showToast("There are no channels to sort", "error");

            const isFiltered = displayedChannels.length < channelsData.length;
            const moveBlockRow = document.getElementById('sort-move-row');
            
            if (isFiltered) {
                moveBlockRow.style.display = 'none';
                if (document.getElementById('sort-move').checked) {
                    document.getElementById('sort-alpha').checked = true;
                }
            } else {
                moveBlockRow.style.display = 'flex';
            }

            const hasSelection = selectedIndices.size > 0;
            
            populateDynamicScopeSelector('sort-scope-selector', {
                filtered: 'Sort Search & Filter Results',
                selected: 'Sort Selected Channels',
                all: 'Sort Entire Playlist'
            });
            
            const moveLabel = document.getElementById('sort-move-label');
            if (hasSelection) {
                moveLabel.textContent = `Move selected (${selectedIndices.size}) to position`;
            } else {
                moveLabel.textContent = 'Move channels to new position';
            }

            document.getElementById('sort-descending').checked = false;
            document.getElementById('sort-grouping').checked = false;

            handleSortCriteriaChange();
            
            openModal('sortModal');
        }
        
        function handleSortCriteriaChange() {
            const criteria = document.querySelector('input[name="sortCriteria"]:checked').value;
            const modalContent = document.querySelector('#sortModal .modal-content');
            
            const nameContainer = document.getElementById('sortByNameInputContainer');
            const groupContainer = document.getElementById('sortByGroupInputContainer');
            const moveContainer = document.getElementById('moveBlockInputContainer');
            
            nameContainer.classList.toggle('visible', criteria === 'name');
            groupContainer.classList.toggle('visible', criteria === 'group');
            moveContainer.classList.toggle('visible', criteria === 'moveBlock');

            modalContent.classList.toggle('compact-layout', criteria === 'moveBlock');
            
            document.getElementById('sort-descending').disabled = false;

            const scopeContainer = document.getElementById('sort-scope-container');
            const scopeIsSubSet = document.getElementById('sort-scope-selector').value !== 'all';
            
            const groupingContainer = document.getElementById('sort-grouping-container');
            groupingContainer.style.display = (criteria !== 'moveBlock' && scopeIsSubSet) ? 'flex' : 'none';

            scopeContainer.style.display = (criteria !== 'moveBlock') ? 'block' : 'none';
            
            const moveRangeContainer = document.getElementById('moveBlockRangeContainer');
            if(moveRangeContainer) {
                moveRangeContainer.style.display = (selectedIndices.size > 0 && criteria === 'moveBlock') ? 'none' : 'block';
            }
        }
        
        function openManageGroupsModal() {
            if (channelsData.length === 0) return showToast("There are no channels to manage groups for", "error");
            const groupSelector = document.getElementById('groupSelector');
            groupSelector.innerHTML = '';

            const isFiltered = displayedChannels.length < channelsData.length;
            const hasSelection = selectedIndices.size > 0;
            const channelWords = {singular: 'channel', plural: 'channels'};
            let defaultSelection = null;

            if (isFiltered) {
                const option = document.createElement('option');
                option.value = '__filtered__';
                const countStr = generateCountString(displayedChannels.length, channelWords);
                option.textContent = `Search & Filter Results (${countStr})`;
                groupSelector.appendChild(option);
                defaultSelection = '__filtered__';
            } 
            if (hasSelection) {
                const option = document.createElement('option');
                option.value = '__selected__';
                const countStr = generateCountString(selectedIndices.size, channelWords);
                option.textContent = `Selected Channels (${countStr})`;
                groupSelector.appendChild(option);
                if (!defaultSelection) {
                    defaultSelection = '__selected__';
                }
            }

            const allGroups = channelsData.flatMap(ch => (ch.groups && ch.groups.length) ? ch.groups : ['Uncategorized']);
            const uniqueGroups = [...new Set(allGroups)];
            uniqueGroups.sort((a, b) => a.localeCompare(b)).forEach(group => {
                const option = document.createElement('option');
                option.value = group;
                option.textContent = group;
                groupSelector.appendChild(option);
            });
            
            if(defaultSelection) {
                groupSelector.value = defaultSelection;
            }

            document.getElementById('action-rename').checked = true;
            document.getElementById('rename-add-as-new').checked = false;
            handleGroupSelectorChange();
            handleGroupActionChange();
            openModal('manageGroupsModal');
        }

        function handleGroupSelectorChange() {
            const groupSelector = document.getElementById('groupSelector');
            const mergeTargetSelector = document.getElementById('mergeTargetSelector');
            const selectedGroup = groupSelector.value;
            
            mergeTargetSelector.innerHTML = '';

            const allGroups = channelsData.flatMap(ch => (ch.groups && ch.groups.length) ? ch.groups : ['Uncategorized']);
            const uniqueGroups = [...new Set(allGroups)];

            uniqueGroups
                .filter(group => group !== selectedGroup)
                .sort((a, b) => a.localeCompare(b))
                .forEach(group => {
                    const option = document.createElement('option');
                    option.value = group;
                    option.textContent = group;
                    mergeTargetSelector.appendChild(option);
            });
            
            document.getElementById('newGroupNameField').placeholder = "Enter new name or leave empty";
            handleGroupActionChange();
        }
        
        function handleGroupActionChange() {
            const action = document.querySelector('input[name="groupAction"]:checked').value;
            const renameContainer = document.getElementById('renameGroupInputContainer');
            const mergeContainer = document.getElementById('mergeGroupInputContainer');
            const groupSelector = document.getElementById('groupSelector');
            const isGlobalAction = action === 'removeAll';

            groupSelector.disabled = isGlobalAction;

            const isDynamicGroup = groupSelector.value === '__filtered__' || groupSelector.value === '__selected__';
            document.getElementById('action-merge').disabled = isDynamicGroup;

            if (isDynamicGroup && action === 'merge') {
                document.getElementById('action-rename').checked = true;
                setTimeout(handleGroupActionChange, 0);
                return; 
            }

            const currentAction = document.querySelector('input[name="groupAction"]:checked').value;
            renameContainer.classList.toggle('visible', currentAction === 'rename');
            mergeContainer.classList.toggle('visible', currentAction === 'merge');
        }
        
        function openMergeModal() {
            if (channelsData.length === 0) {
                return showToast("You must load a playlist first to merge with", "error");
            }
            document.getElementById('mergeUrlTextarea').value = '';
            document.getElementById('mergeOptionSelector').value = 'file';
            handleMergeOptionChange();
            openModal('mergeModal');
        }

        function handleMergeOptionChange() { const selectedOption = document.getElementById('mergeOptionSelector').value; document.getElementById('mergeFileOption').style.display = (selectedOption === 'file') ? 'block' : 'none'; document.getElementById('mergeUrlOption').style.display = (selectedOption === 'url') ? 'block' : 'none'; }
        
        function showPlaylistControls() {
            document.getElementById('uploadArea').style.display = 'none';
            document.getElementById('urlLoadContainer').style.display = 'none';
            document.getElementById('toolsMergeRow').style.display = 'flex';
            ['openSortModalButton', 'manageGroupsButton', 'openSearchFilterModalButton', 'bulkActionsButton'].forEach(id => {
                const button = document.getElementById(id);
                if (button) {
                     button.style.display = 'inline-block';
                }
            });
            updateBulkActionsUI();
        }
        
        function updateLogoPreview(imgId, url) { const preview = document.getElementById(imgId); preview.style.display = url ? 'block' : 'none'; if(url) preview.src = url; preview.onerror = () => preview.style.display = 'none'; }
        document.getElementById('editLogo').addEventListener('input', e => updateLogoPreview('previewImage', e.target.value)); document.getElementById('addLogo').addEventListener('input', e => updateLogoPreview('addPreviewImage', e.target.value));
        function buildUpdatedExtinf(originalExtinf, groups, logo, name, chno) { let line = originalExtinf ? originalExtinf.replace(/,.*$/, '').split(/\s+/).filter(p => !p.toLowerCase().startsWith('group-title=') && !p.toLowerCase().startsWith('tvg-logo=') && !p.toLowerCase().startsWith('tvg-chno=')).join(' ') : '#EXTINF:-1'; if (chno) line += ` tvg-chno="${chno}"`; if (logo) line += ` tvg-logo="${logo}"`; if (groups && groups.length > 0) line += ` group-title="${groups.join(';')}"`; return `${line},${name}`; }
        function updateTvgChnoInAllChannels() { channelsData.forEach((channel, index) => { channel.chno = index + 1; channel.originalExtinf = buildUpdatedExtinf(channel.originalExtinf, channel.groups, channel.logo, channel.name, channel.chno); }); }
        function openExportModal() { if (channelsData.length === 0) return showToast("There are no channels to export", "error"); openModal('exportModal'); }
        
        function executeExport() {
            const format = document.querySelector('input[name="exportFormat"]:checked').value;
            const numSelected = selectedIndices.size;

            const exportFunction = (channels) => {
                if (channels.length === 0) {
                    return showToast("No channels selected for export.", "error");
                }
                if (format === 'm3u') savePlaylist(channels);
                else if (format === 'm3u8') savePlaylistAsM3u8(channels);
                else if (format === 'pls') savePlaylistAsPls(channels);
                else if (format === 'json') savePlaylistAsJson(channels);
                else if (format === 'csv') savePlaylistAsCsv(channels);
                else if (format === 'enigma2') saveEnigma2Bouquets(channels);
            };

            closeModal('exportModal');

            if (numSelected > 0) {
                const countStr = generateCountString(numSelected, {singular: 'channel', plural: 'channels'});
                showConfirm(
                    'Export Selected Channels',
                    `Only the selected ${countStr} will be exported. Do you want to continue?`,
                    () => {
                        const selectedChannels = Array.from(selectedIndices).map(index => channelsData[index]);
                        exportFunction(selectedChannels);
                        selectedIndices.clear();
                        searchChannels();
                    }
                );
                return;
            }

            const isFiltered = displayedChannels.length < channelsData.length && channelsData.length > 0;
            if (isFiltered) {
                const countStr = generateCountString(displayedChannels.length, {singular: 'channel', plural: 'channels'});
                showConfirm(
                    'Export Filtered Channels',
                    `Only the channels from the search and filter results (${countStr}) will be exported. Do you want to continue?`,
                    () => { exportFunction(displayedChannels); }
                );
            } else {
                exportFunction(channelsData);
            }
        }

        const createPlaylistContent = (type, channelsToExport = channelsData) => { if (channelsToExport.length === 0) { showToast("No channels to save", "error"); return null; } if (type === 'pls') { return '[playlist]\nNumberOfEntries=' + channelsToExport.length + '\nVersion=2\n' + channelsToExport.map((ch, i) => `File${i+1}=${ch.url}\nTitle${i+1}=${ch.name}\nLength${i+1}=-1`).join('\n'); } return '#EXTM3U\n' + channelsToExport.map(ch => `${buildUpdatedExtinf(ch.originalExtinf, ch.groups, ch.logo, ch.name, ch.chno)}\n${ch.url}`).join('\n\n'); }
        function savePlaylist(channelsToExport = channelsData) { const c = createPlaylistContent('m3u', channelsToExport); if(c) downloadFile(c, 'playlist.m3u', 'text/plain;charset=utf-8'); }
        function savePlaylistAsM3u8(channelsToExport = channelsData) { const c = createPlaylistContent('m3u8', channelsToExport); if(c) downloadFile(c, 'playlist.m3u8', 'application/x-mpegurl;charset=utf-8'); }
        function savePlaylistAsPls(channelsToExport = channelsData) { const c = createPlaylistContent('pls', channelsToExport); if(c) downloadFile(c, 'playlist.pls', 'audio/x-scpls;charset=utf-8'); }

        function savePlaylistAsJson(channelsToExport = channelsData) {
            const content = JSON.stringify(channelsToExport, null, 2);
            downloadFile(content, 'playlist.json', 'application/json;charset=utf-8');
        }

        function savePlaylistAsCsv(channelsToExport = channelsData) {
            const escapeCsvField = (field) => {
                if (field === undefined || field === null) {
                    return '';
                }
                const stringField = String(field);
                if (stringField.includes(',') || stringField.includes('"') || stringField.includes('\n')) {
                    return `"${stringField.replace(/"/g, '""')}"`;
                }
                return stringField;
            };

            const header = ['name', 'logo', 'url', 'groups'].join(',');
            const rows = channelsToExport.map(ch => {
                const name = escapeCsvField(ch.name);
                const logo = escapeCsvField(ch.logo);
                const url = escapeCsvField(ch.url);
                const groups = escapeCsvField((ch.groups || []).join(';'));
                return [name, logo, url, groups].join(',');
            });
            const content = [header, ...rows].join('\n');
            downloadFile(content, 'playlist.csv', 'text/csv;charset=utf-8;');
        }

        async function saveEnigma2Bouquets(channelsToExport = channelsData) {
            if (channelsToExport.length === 0) { showToast("No channels to save", "error"); return; }
            const zip = new JSZip();
            const allGroups = new Set(channelsToExport.flatMap(ch => (ch.groups && ch.groups.length) ? ch.groups : []));
            const bouquets = [];
            for (const group of allGroups) {
                const groupChannels = channelsToExport.filter(ch => ch.groups && ch.groups.includes(group));
                if (groupChannels.length === 0) continue;
                const sanitizedGroupName = group.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
                const bouquetFileName = `userbouquet.${sanitizedGroupName}.tv`;
                bouquets.push(bouquetFileName);
                let bouquetContent = `#NAME ${group}\n`;
                groupChannels.forEach(ch => {
                    const encodedUrl = encodeURIComponent(ch.url).replace(/:/g, '%3a');
                    bouquetContent += `#SERVICE 4097:0:1:0:0:0:0:0:0:0:${encodedUrl}:${ch.name}\n`;
                });
                zip.file(bouquetFileName, bouquetContent);
            }
            let bouquetsTvContent = '#NAME Bouquets (TV)\n';
            bouquets.forEach(b => {
                bouquetsTvContent += `#SERVICE 1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "${b}" ORDER BY bouquet\n`;
            });
            zip.file('bouquets.tv', bouquetsTvContent);
            try {
                const content = await zip.generateAsync({type:"blob"});
                const a = document.createElement('a');
                a.href = URL.createObjectURL(content);
                a.download = 'enigma2_bouquets.zip';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            } catch(e) {
                showToast("An error occurred while creating the ZIP file.", "error");
            }
        }

        function downloadFile(content, fileName, mimeType) { const blob = new Blob([new Uint8Array([0xEF, 0xBB, 0xBF]), content], { type: mimeType }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); const prefix = isMerged ? 'merged_' : isSorted ? 'sorted_' : ''; a.download = prefix + fileName; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href); }
        
        function handleBulkActionChange() {
            const selectedAction = document.querySelector('input[name="bulkAction"]:checked').value;
            document.getElementById('bulk-move-input-container').classList.toggle('visible', selectedAction === 'move');
            document.getElementById('bulk-edit-group-container').classList.toggle('visible', selectedAction === 'group');
        }

        function executeBulkAction() {
            const selectedAction = document.querySelector('input[name="bulkAction"]:checked').value;
            
            if (selectedAction === 'move') {
                const target = parseInt(document.getElementById('bulk-move-target-index').value);
                if (isNaN(target)) { return showToast('Please enter the target position', 'error'); }
                const maxIndex = channelsData.length;
                if (target < 1 || target > maxIndex + 1) { return showToast(`Target position is outside the list range (1 - ${maxIndex})`, 'error'); }
                
                const sortedIndices = Array.from(selectedIndices).sort((a, b) => b - a);
                const blockToMove = [];
                sortedIndices.forEach(index => {
                    blockToMove.unshift(channelsData.splice(index, 1)[0]);
                });
                
                channelsData.splice(target - 1, 0, ...blockToMove);
                selectedIndices.clear();
                updateAndRefreshUI();
                setTimeout(() => closeModal('bulkActionsModal'), 0);
                return;
            } else if (selectedAction === 'group') {
                const newGroups = document.getElementById('bulk-new-group-name').value.split(';').map(g => g.trim()).filter(g => g); 
                selectedIndices.forEach(index => { channelsData[index].groups = newGroups; }); 
                updateAndRefreshUI(); 
                populateGroupFilter(); 
                setTimeout(() => closeModal('bulkActionsModal'), 0); 
                return;
            }

            setTimeout(() => closeModal('bulkActionsModal'), 0);

            switch(selectedAction) {
                case 'sort':
                    const indices = Array.from(selectedIndices).sort((a, b) => a - b);
                    const channelsToSort = indices.map(index => channelsData[index]);
                    channelsToSort.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
                    indices.forEach((originalIndex, i) => {
                        channelsData[originalIndex] = channelsToSort[i];
                    });
                    
                    updateAndRefreshUI();
                    break;
                case 'removeGroup':
                    undoManager.registerUndo();
                    const count = selectedIndices.size;
                    selectedIndices.forEach(index => {
                        channelsData[index].groups = [];
                    });
                    updateAndRefreshUI();
                    populateGroupFilter();
                    const countStr = generateCountString(count, {singular: 'channel', plural: 'channels'});
                    showToast(`Removed group from ${countStr}.`, 'success', 8000, {
                        text: 'Undo',
                        callback: () => undoManager.performUndo()
                    });
                    break;
                case 'export':
                    exportSelected();
                    break;
                case 'delete':
                    deleteSelected();
                    break;
            }
        }

        function exportSelected() { if (selectedIndices.size === 0) return; openModal('exportModal'); }
        
        function handleChannelCheckClick() {
            if (isCheckPerformed) {
                clearChannelCheckBadges();
            } else {
                openChannelCheckerModal();
            }
        }

        function updateChannelCheckMenu() {
            const checkerButton = document.querySelector('#modal-options-list button[onclick*="handleChannelCheckClick"]');
            if (checkerButton) {
                checkerButton.textContent = isCheckPerformed ? 'Clear Check Badges' : 'Check Ch. Status';
            }
        }

        function clearChannelCheckBadges() {
            isCheckPerformed = false;
            channelsData.forEach(channel => {
                channel.status = 'unchecked';
            });
            displayPaginatedChannels();
            updateChannelCheckMenu();
        }

        function openChannelCheckerModal() {
            if (channelsData.length === 0) return showToast("There are no channels to check", "error");
            
            document.getElementById('checker-progress-text').textContent = "Press 'Start Check' to verify channel statuses.";
            const progressBar = document.getElementById('checker-progress-bar');
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';
            document.getElementById('checker-summary-text').textContent = '';

            document.querySelector('#channelCheckerModal .modal-buttons').style.display = 'flex';
            document.getElementById('start-check-btn').style.display = 'inline-block';
            document.getElementById('checker-cancel-btn').style.display = 'inline-block';
            document.getElementById('stop-check-btn').style.display = 'none';
            
            const actionsContainer = document.getElementById('checker-actions-container');
            actionsContainer.style.display = 'none';
            actionsContainer.querySelector('.dropdown-btn').textContent = 'Actions ▼';

            openModal('channelCheckerModal');
        }

        function stopChannelCheck() { isChecking = false; }
        
        function resetAllStatusDots() {
            channelsData.forEach(channel => {
                channel.status = 'unchecked';
            });
            const allDots = document.querySelectorAll('#results .status-dot');
            allDots.forEach(dot => {
                dot.style.display = 'none';
                dot.className = 'status-dot unchecked';
            });
        }

        function updateStatusDot(originalIndex, status) {
            const dot = document.querySelector(`.status-dot[data-index="${originalIndex}"]`);
            if (dot) {
                dot.className = `status-dot ${status}`;
                dot.style.display = 'inline-block';
            }
        }

        async function executeChannelCheck() {
            isChecking = true;
            resetAllStatusDots();

            let channelsToCheck;
            const isFiltered = displayedChannels.length < channelsData.length;
            const hasSelection = selectedIndices.size > 0;

            if (hasSelection) {
                channelsToCheck = Array.from(selectedIndices).map(index => channelsData[index]);
            } else if (isFiltered) {
                channelsToCheck = displayedChannels;
            } else {
                channelsToCheck = channelsData;
            }

            if (channelsToCheck.length === 0) {
                isChecking = false;
                return;
            }

            const topButtonRow = document.querySelector('#channelCheckerModal .modal-buttons');
            topButtonRow.style.display = 'flex';
            document.getElementById('start-check-btn').style.display = 'none';
            document.getElementById('stop-check-btn').style.display = 'inline-block';
            document.getElementById('checker-cancel-btn').style.display = 'none';
            document.getElementById('checker-actions-container').style.display = 'none';

            const progressText = document.getElementById('checker-progress-text');
            const progressBar = document.getElementById('checker-progress-bar');
            const summaryText = document.getElementById('checker-summary-text');
            let okCount = 0;
            let failCount = 0;
            const total = channelsToCheck.length;

            for (let i = 0; i < total; i++) {
                if (!isChecking) break;
                
                const channel = channelsToCheck[i];
                const originalIndex = channelsData.indexOf(channel);

                if (originalIndex === -1) continue;

                channel.status = 'checking';
                updateStatusDot(originalIndex, 'checking');
                
                const progress = Math.round(((i + 1) / total) * 100);
                progressText.textContent = `Checking channel ${i + 1} of ${total}...`;
                progressBar.style.width = `${progress}%`;
                progressBar.textContent = `${progress}%`;
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                try {
                    const response = await fetch(channel.url, { method: 'HEAD', signal: controller.signal, mode: 'no-cors' });
                    channel.status = 'checked-ok';
                    okCount++;
                } catch (error) {
                    channel.status = 'checked-fail';
                    failCount++;
                } finally {
                    clearTimeout(timeoutId);
                    updateStatusDot(originalIndex, channel.status);
                }
            }
            
            isChecking = false;
            const checkedCount = okCount + failCount;
            if (checkedCount > 0) {
                isCheckPerformed = true;
                updateChannelCheckMenu();
            }

            const channelWords = {singular: 'channel', plural: 'channels'};
            const okStr = generateCountString(okCount, channelWords);
            const failStr = generateCountString(failCount, channelWords);
            summaryText.textContent = `Check complete: ${okStr} working, ${failStr} not working.`;
            
            const actionsContainer = document.getElementById('checker-actions-container');

            if (failCount > 0) {
                topButtonRow.style.display = 'none';
                
                document.getElementById('delete-failed-btn').style.display = 'block';
                document.getElementById('select-failed-btn').style.display = 'block';
                document.getElementById('export-working-btn').style.display = okCount > 0 ? 'block' : 'none';
                
                actionsContainer.querySelector('.dropdown-btn').textContent = `Actions (${failStr} not working)`;
                actionsContainer.style.display = 'block';

            } else {
                topButtonRow.style.display = 'flex';
                document.getElementById('start-check-btn').style.display = 'none';
                document.getElementById('stop-check-btn').style.display = 'none';
                document.getElementById('checker-cancel-btn').style.display = 'inline-block';
                actionsContainer.style.display = 'none';
            }
        }
        
        function toggleCheckerActions() {
            document.getElementById("checker-actions-dropdown").classList.toggle("show");
        }
        
        window.addEventListener('click', function(event) {
            if (!event.target.matches('.dropdown-btn')) {
                document.querySelectorAll("#checker-actions-dropdown.show").forEach(openDropdown => {
                    openDropdown.classList.remove('show');
                });
            }

            document.querySelectorAll('.modal').forEach(m => {
                if (event.target === m) closeModal(m.id);
            });
        });

        function deleteFailedChannels() {
            toggleCheckerActions();
            const failedChannels = channelsData.filter(ch => ch.status === 'checked-fail');
            if (failedChannels.length === 0) return;

            undoManager.registerUndo();
            
            channelsData = channelsData.filter(ch => ch.status !== 'checked-fail');
            
            updateAndRefreshUI();
            closeModal('channelCheckerModal');
            
            const countStr = generateCountString(failedChannels.length, {singular: 'non-working channel', plural: 'non-working channels'});
            showToast(`Deleted ${countStr}.`, 'success', 8000, {
                text: 'Undo',
                callback: () => undoManager.performUndo()
            });
        }

        function exportWorkingChannels() {
            toggleCheckerActions();
            const workingChannels = channelsData.filter(ch => ch.status === 'checked-ok');
            if (workingChannels.length === 0) return;
            
            const content = createPlaylistContent('m3u', workingChannels);
            if (content) {
                downloadFile(content, 'working_channels.m3u', 'text/plain;charset=utf-8');
            }
            closeModal('channelCheckerModal');
        }

        function selectFailedChannels() {
            toggleCheckerActions();
            const failedChannels = channelsData.filter(ch => ch.status === 'checked-fail');
            if (failedChannels.length === 0) return;
            
            displayedChannels = failedChannels;
            
            selectedIndices.clear();
            failedChannels.forEach(channel => {
                const originalIndex = channelsData.indexOf(channel);
                if (originalIndex !== -1) selectedIndices.add(originalIndex);
            });

            currentPage = 1;
            displayPaginatedChannels();
            closeModal('channelCheckerModal');
        }

        /* --- START: MODIFIED FILTER LOGIC --- */
        
        function handleFilterButtonClick() {
            // If a filter is active, the button's only job is to cancel it.
            if (isFilterActiveForButton) {
                document.getElementById('searchInput').value = '';
                document.getElementById('groupFilter').value = 'all';
                searchChannels(); // This will reset the view and the button text
            } else {
                // If no filter is active, the button opens the modal.
                openModal('searchFilterModal');
            }
        }

        function searchChannels() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const selectedGroup = document.getElementById('groupFilter').value;
            let tempChannels = channelsData;
            if (selectedGroup !== 'all') {
                tempChannels = channelsData.filter(ch => {
                    if (selectedGroup === 'uncategorized') { return !ch.groups || ch.groups.length === 0; }
                    return ch.groups && ch.groups.includes(selectedGroup);
                });
            }
            if (searchTerm) {
                displayedChannels = tempChannels.filter(ch => (ch.name || '').toLowerCase().includes(searchTerm) || (ch.groups && ch.groups.join(' ').toLowerCase().includes(searchTerm)));
            } else {
                displayedChannels = [...tempChannels];
            }
            currentPage = 1;
            isFilterActiveForButton = (searchTerm !== '' || selectedGroup !== 'all');

            const filterButton = document.getElementById('openSearchFilterModalButton');
            if (filterButton) {
                // Update button text based on whether a filter is active
                filterButton.textContent = isFilterActiveForButton ? 'Clear Search & Filter' : 'Search & Filter';
            }

            displayPaginatedChannels();
        }

        function setupSearchFilterModal() {
            const groupFilter = document.getElementById('groupFilter');
            const actionButton = document.getElementById('searchFilterActionButton');

            const currentGroup = groupFilter.value;
            populateGroupFilter('groupFilter');
            groupFilter.value = currentGroup;

            actionButton.onclick = applyFilter;
        }

        function applyFilter() {
            searchChannels();
            closeModal('searchFilterModal');
        }
        
        /* --- END: MODIFIED FILTER LOGIC --- */
        
        function handleCaseTypeChange() {
            const exceptionsContainer = document.getElementById('title-case-exceptions-container');
            exceptionsContainer.style.display = document.getElementById('case-title').checked ? 'block' : 'none';
        }

        function openFormatDataModal() {
            if (channelsData.length === 0) return showToast("There are no channels to format", "error");

            populateDynamicScopeSelector('format-scope-selector', {
                filtered: 'Format Search & Filter Results',
                selected: 'Format Selected Channels',
                all: 'Format Entire Playlist'
            });
            
            document.querySelectorAll('input[name="formatCase"]').forEach(radio => {
                radio.onchange = handleCaseTypeChange;
            });
            
            document.getElementById('case-none').checked = true;
            document.getElementById('format-prefix').value = '';
            document.getElementById('format-suffix').value = '';
            document.getElementById('format-trim').checked = true;
            document.getElementById('format-remove-logos').checked = false;
            document.getElementById('find-text').value = '';
            document.getElementById('replace-text').value = '';
            document.getElementById('find-in-name').checked = true;
            document.getElementById('find-in-group').checked = false;
            document.getElementById('find-in-url').checked = false;
            document.getElementById('format-remove-words-toggle').checked = false;
            document.getElementById('remove-words-container').classList.remove('visible');
            document.getElementById('format-remove-words-input').value = '';
            
            const savedExceptions = localStorage.getItem('m3uEditorTitleCaseExceptions');
            const exceptionsInput = document.getElementById('title-case-exceptions-input');
            exceptionsInput.value = savedExceptions || '';

            handleCaseTypeChange();
            document.getElementById('defaultFormatOpen').click();

            openModal('formatDataModal');
        }

        const titleCaseExceptions = ['TV', 'SD', 'HD', 'FHD', 'UHD', '4K', '8K', 'HEVC', 'H265', 'VIP', '3D', 'OSN', 'ART', 'SSC'];

        function smartTitleCase(str, exceptions) {
            if (!str) return '';
            let words = str.toLowerCase().split(' ');
            return words.map(word => {
                if (exceptions.includes(word.toUpperCase())) {
                    return word.toUpperCase();
                } else {
                    return word.charAt(0).toUpperCase() + word.slice(1);
                }
            }).join(' ');
        }

        function executeFormatting() {
            const scope = document.getElementById('format-scope-selector').value;
            let targetChannels;
            if (scope === 'selected' && selectedIndices.size > 0) {
                targetChannels = Array.from(selectedIndices).map(index => channelsData[index]);
            } else if (scope === 'filtered') {
                targetChannels = [...displayedChannels];
            } else {
                targetChannels = [...channelsData];
            }
            
            if (targetChannels.length === 0) {
                closeModal('formatDataModal');
                return;
            }
            
            let affectedChannelsCount = 0;
            const activeTabId = document.querySelector('.format-tab-pane.active').id;

            targetChannels.forEach(channel => {
                let modified = false;
                
                if (activeTabId === 'FormatCase') {
                    const caseType = document.querySelector('input[name="formatCase"]:checked').value;
                    if (caseType !== 'none' && channel.name) {
                        let originalName = channel.name;
                        if (caseType === 'upper') channel.name = channel.name.toUpperCase();
                        else if (caseType === 'lower') channel.name = channel.name.toLowerCase();
                        else if (caseType === 'title') {
                            const userExceptionsText = document.getElementById('title-case-exceptions-input').value;
                            localStorage.setItem('m3uEditorTitleCaseExceptions', userExceptionsText);

                            let finalExceptions = [...titleCaseExceptions];
                            if (userExceptionsText.trim()) {
                                const userExceptionsArray = userExceptionsText.split(',').map(ex => ex.trim().toUpperCase()).filter(ex => ex);
                                finalExceptions = [...new Set([...finalExceptions, ...userExceptionsArray])];
                            }
                            channel.name = smartTitleCase(channel.name, finalExceptions);
                        }
                        if (originalName !== channel.name) modified = true;
                    }
                } else if (activeTabId === 'FormatAffix') {
                    const prefix = document.getElementById('format-prefix').value;
                    const suffix = document.getElementById('format-suffix').value;
                    let nameChanged = false;
                    if (prefix && channel.name) {
                        channel.name = `${prefix.trim()} ${channel.name.trim()}`;
                        nameChanged = true;
                    }
                    if (suffix && channel.name) {
                        channel.name = `${channel.name.trim()} ${suffix.trim()}`;
                        nameChanged = true;
                    }
                    if(nameChanged) {
                        channel.name = channel.name.trim().replace(/\s+/g, ' ');
                        modified = true;
                    }
                } else if (activeTabId === 'FormatReplace') {
                    const findText = document.getElementById('find-text').value;
                    if (findText) {
                        const replaceText = document.getElementById('replace-text').value;
                        const findInName = document.getElementById('find-in-name').checked;
                        const findInGroup = document.getElementById('find-in-group').checked;
                        const findInUrl = document.getElementById('find-in-url').checked;

                        if (findInName && channel.name && channel.name.includes(findText)) {
                            const original = channel.name;
                            channel.name = channel.name.replaceAll(findText, replaceText);
                            if (original !== channel.name) modified = true;
                        }
                        if (findInGroup && channel.groups && channel.groups.length > 0) {
                            const originalGroups = [...channel.groups];
                            channel.groups = channel.groups.map(group => group.replaceAll(findText, replaceText));
                            if(JSON.stringify(originalGroups) !== JSON.stringify(channel.groups)) modified = true;
                        }
                        if (findInUrl && channel.url && channel.url.includes(findText)) {
                            const original = channel.url;
                            channel.url = channel.url.replaceAll(findText, replaceText);
                            if (original !== channel.url) modified = true;
                        }
                    }
                } else if (activeTabId === 'FormatClean') {
                    const shouldTrim = document.getElementById('format-trim').checked;
                    const shouldRemoveLogos = document.getElementById('format-remove-logos').checked;
                    const shouldRemoveWords = document.getElementById('format-remove-words-toggle').checked;
                    
                    if (shouldTrim) {
                        if (channel.name) {
                            const originalName = channel.name;
                            channel.name = channel.name.trim().replace(/\s+/g, ' ');
                            if (originalName !== channel.name) modified = true;
                        }
                        if (channel.groups && channel.groups.length > 0) {
                            const originalGroups = [...channel.groups];
                            channel.groups = channel.groups.map(g => g.trim().replace(/\s+/g, ' ')).filter(g => g);
                            if (JSON.stringify(originalGroups) !== JSON.stringify(channel.groups)) modified = true;
                        }
                    }
                    if (shouldRemoveLogos && channel.logo) {
                        channel.logo = '';
                        modified = true;
                    }
                    if (shouldRemoveWords) {
                        const wordsToRemoveText = document.getElementById('format-remove-words-input').value.trim();
                        if (wordsToRemoveText && channel.name) {
                            const originalName = channel.name;
                            const wordsToRemove = wordsToRemoveText.split(',').map(w => w.trim()).filter(w => w);
                            wordsToRemove.forEach(word => {
                                const regex = new RegExp(word.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi');
                                channel.name = channel.name.replace(regex, '');
                            });
                            channel.name = channel.name.trim().replace(/\s+/g, ' ');
                            if (originalName !== channel.name) modified = true;
                        }
                    }
                }

                if (modified) affectedChannelsCount++;
            });

            setTimeout(() => closeModal('formatDataModal'), 0);
            
            if (affectedChannelsCount > 0) {
                updateAndRefreshUI();
            }
        }

        function openLibraryTab(evt, tabName) {
            let i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("library-tab-pane");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            tablinks = document.getElementsByClassName("library-tab-btn");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
        }
        
        function openFormatTab(evt, tabName) {
            let i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("format-tab-pane");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].classList.remove('active');
            }
            tablinks = document.getElementsByClassName("format-tab-btn");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].classList.remove('active');
            }
            document.getElementById(tabName).classList.add('active');
            evt.currentTarget.classList.add('active');
        }
        
        function debouncedFilterLibrary(input, select) {
            clearTimeout(debounceTimeout);
            debounceTimeout = setTimeout(() => {
                performFilter(input, select);
            }, 200);
        }

        function performFilter(input, select) {
            const searchTerm = input.value.toLowerCase().trim();
            let firstVisibleIndex = -1;

            for (let i = 0; i < select.options.length; i++) {
                const option = select.options[i];
                const optionText = option.text.toLowerCase();
                const isPlaceholder = option.value === "";

                if (isPlaceholder || optionText.includes(searchTerm)) {
                    option.style.display = 'block';
                    if (firstVisibleIndex === -1 && !isPlaceholder) {
                        firstVisibleIndex = i;
                    }
                } else {
                    option.style.display = 'none';
                }
            }

            if (firstVisibleIndex !== -1) {
                select.selectedIndex = firstVisibleIndex;
            } else {
                select.selectedIndex = 0;
            }
        }
        
        function setupLibraryFilter(inputId, selectId) {
            const searchInput = document.getElementById(inputId);
            const selectElement = document.getElementById(selectId);
            searchInput.addEventListener('input', () => debouncedFilterLibrary(searchInput, selectElement));
        }

        async function openLibraryImportModal() {
            openModal('libraryImportModal');
            document.getElementById('defaultOpenTab').click();

            if (isLibraryDataFetched) return; 

            const loadingIndicator = document.getElementById('library-loading-indicator');
            const tabPanes = document.querySelectorAll('.library-tab-pane');
            
            loadingIndicator.style.display = 'block';
            tabPanes.forEach(pane => pane.style.display = 'none');

            try {
                const [countriesRes, languagesRes, categoriesRes] = await Promise.all([
                    fetch('https://iptv-org.github.io/api/countries.json'),
                    fetch('https://iptv-org.github.io/api/languages.json'),
                    fetch('https://iptv-org.github.io/api/categories.json')
                ]);

                if (!countriesRes.ok || !languagesRes.ok || !categoriesRes.ok) {
                    throw new Error('Failed to fetch one of the library lists');
                }

                const countries = await countriesRes.json();
                const languages = await languagesRes.json();
                const categories = await categoriesRes.json();
                
                const countryFilter = document.getElementById('libraryCountryFilter');
                const languageFilter = document.getElementById('libraryLanguageFilter');
                const categoryFilter = document.getElementById('libraryCategoryFilter');

                countries.forEach(c => countryFilter.add(new Option(c.name, c.code)));
                languages.forEach(l => languageFilter.add(new Option(l.name, l.code)));
                categories.forEach(c => categoryFilter.add(new Option(c.name, c.id)));
                
                setupLibraryFilter('countrySearchInput', 'libraryCountryFilter');
                setupLibraryFilter('languageSearchInput', 'libraryLanguageFilter');
                setupLibraryFilter('categorySearchInput', 'libraryCategoryFilter');
                
                isLibraryDataFetched = true;

            } catch (error) {
                console.error("Error fetching library data:", error);
                showToast("An error occurred while fetching library lists.", "error");
                closeModal('libraryImportModal');
            } finally {
                loadingIndicator.style.display = 'none';
                document.getElementById('Country').style.display = 'block';
            }
        }

        async function executeLibraryImport() {
            const importAction = document.querySelector('input[name="importAction"]:checked').value;
            let url = '', selectedValue = '';

            const activeTab = document.querySelector('.library-tab-pane[style*="block"]');
            if (!activeTab) return showToast("An unexpected error occurred.", "error");

            const selectElement = activeTab.querySelector('select');
            selectedValue = selectElement.value;
            
            if (!selectedValue) {
                return showToast("Please select an item from the list first.", "error");
            }
            
            switch(activeTab.id) {
                case 'Country':
                    url = `https://iptv-org.github.io/iptv/countries/${selectedValue.toLowerCase()}.m3u`;
                    break;
                case 'Language':
                    url = `https://iptv-org.github.io/iptv/languages/${selectedValue}.m3u`;
                    break;
                case 'Category':
                    url = `https://iptv-org.github.io/iptv/categories/${selectedValue}.m3u`;
                    break;
            }

            closeModal('libraryImportModal');
            document.getElementById('loadingIndicator').style.display = 'block';

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Failed to load the channel list');
                const content = await response.text();
                const channelsFromLibrary = parseM3uPlaylist(content);

                if (channelsFromLibrary.length === 0) {
                    showToast("No channels were found in the selected item.", "info");
                    return;
                }

                if (importAction === 'replace') {
                    undoManager.registerUndo();
                    channelsData = [];
                    isCheckPerformed = false;
                    updateChannelCheckMenu();
                }
                
                const countStr = generateCountString(channelsFromLibrary.length, {singular: 'channel', plural: 'channels'});
                const actionText = importAction === 'replace' ? 'Replaced playlist with' : 'Merged';
                
                processNewChannels(channelsFromLibrary, `Successfully ${actionText.toLowerCase()} ${countStr}.`);

                if (importAction === 'replace') {
                     showToast(`The current playlist has been replaced.`, 'info', 8000, {
                        text: 'Undo',
                        callback: () => undoManager.performUndo()
                    });
                }
                showPlaylistControls();

            } catch (error) {
                console.error("Error importing from library:", error);
                showToast("An error occurred while importing channels.", "error");
            } finally {
                document.getElementById('loadingIndicator').style.display = 'none';
            }
        }

        const themeToggle = document.getElementById('theme-toggle');
        const currentTheme = localStorage.getItem('theme');

        function applyTheme(theme) {
            if (theme === 'dark') {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
        }

        function toggleTheme() {
            if (document.body.classList.contains('dark-mode')) {
                document.body.classList.remove('dark-mode');
                localStorage.setItem('theme', 'light');
            } else {
                document.body.classList.add('dark-mode');
                localStorage.setItem('theme', 'dark');
            }
        }

        if (currentTheme) {
            applyTheme(currentTheme);
        } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            applyTheme('dark');
        }

        if (themeToggle) {
            themeToggle.addEventListener('click', toggleTheme);
        }
        
        if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/en/sw.js') // <-- تأكد أن المسار هنا صحيح
            .then(registration => {
                console.log('ServiceWorker registration successful');
            })
            .catch(error => {
                console.log('ServiceWorker registration failed: ', error);
            });
    });
}
    
    </script>
</body>
</html>


